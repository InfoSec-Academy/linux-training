[{"id":0,"href":"/linux-training/docs/102/network/network/","title":"Ağ Güvenliği","section":"Network","content":"Linux, birçok farklı ağ protokolü için destek sunar ve birçok ağ yönetimi aracı ve güvenlik aracı da içerir. Ağ yönetimi, ağınızı yapılandırmak, ağınızda bağlı cihazları görüntülemek, ağ bağlantılarını izlemek ve ağ sorunlarını çözmek için kullanabileceğiniz bir dizi aracı içerir. Güvenlik, Linux\u0026rsquo;ta oldukça önemli bir konudur ve bir dizi araç, güvenliği artırmak ve ağınızı korumak için kullanılabilir. Bazı popüler ağ yönetimi ve güvenlik araçları şunlardır:\n  tcpdump: Ağ trafiğini izlemek ve analiz etmek için kullanılan bir araçtır. Ağınızda gerçekleşen tüm trafiği kaydedebilir ve incelenebilir hale getirebilirsiniz. Bu araç, ağ sorunlarını tespit etmek ve güvenliği artırmak için kullanılabilir.\n  iptables: Linux\u0026rsquo;un en popüler güvenlik araçlarından biridir. Bu araç, ağ trafiğini filtrelemek, ağınızda bulunan cihazların erişimini sınırlamak ve diğer güvenlik görevlerini gerçekleştirmek için kullanılır.\n  fail2ban: Ağ güvenliğini artırmak için kullanabileceğiniz bir diğer araçtır. Bu araç, ağınıza başarısız giriş denemeleri yapıldığında otomatik olarak IP adreslerini engeller ve ağınızı korur.\n  "},{"id":1,"href":"/linux-training/docs/102/monitoring/atop/","title":"atop","section":"Monitoring","content":"atop Linux sistemlerinde sistem kaynaklarının takibini yapmak için kullanılan bir araçtır. atop, CPU, bellek, disk ve ağ kullanımı gibi sistem kaynaklarını izleyerek ayrıntılı raporlar sağlar. atop, birçok Linux dağıtımında varsayılan olarak yüklü olmayabilir, bu nedenle öncelikle sisteminize yüklemeniz gerekebilir.\napt-get install atop yum install atop örnek bir atop çıktısı;\nPRC | sys 4.27s | user 3.46s | #proc 165 | #zombie 0 | #exit 0 | CPU | sys\t5% | user 6% | irq 0% | idle 186% | wait 2% | cpu | sys\t3% | user 4% | irq 0% | idle 91% | cpu001 w 2% | cpu | sys\t2% | user 2% | irq 0% | idle 95% | cpu000 w 0% | CPL | numcpu 2 | avg1 0.04 | avg5 0.05 | csw 97534 | intr 78868 | MEM | tot 1.9G | free 1.1G | cache 451.2M | buff 2.0M | slab 99.5M | MEM | numnode 1 | shmem 5.0M | shrss 0.0M | tcpsk 0.0M | udpsk 0.0M | SWP | tot 1.9G | free 1.9G | swcac 0.0M | vmcom 699.0M | vmlim 2.9G | PAG | migrate 0 | pgin 122095 | pgout 11190 | swout 0 | oomkill 0 | PSI | cpusome 1% | memsome 0% | memfull 0% | iosome 1% | iofull 1% | DSK | vda | busy 6% | read 11492 | write 708 | avio 0.85 ms | NET | transport | tcpi 977 | tcpo 972 | udpi 27 | udpo 29 | NET | network\t| ipi 1012 | ipo 1017 | ipfrw 0 | deliv 1004 | NET | enp1s0 ---- | pcki 1134 | pcko 1020 | si 14 Kbps | so 7 Kbps | NET | lo ---- | pcki\t4 | pcko 4 | si 0 Kbps | so 0 Kbps | Yukarıdaki çıktının anlamları;\n PRC: sistem kaynaklarının (CPU, bellek, disk, ağ) kullanımına ilişkin bilgileri içerir. CPU: CPU kullanımını, bekleme sürelerini ve kesme (interrupt) oranlarını gösterir. CPL: işlemci yükünü gösterir. Bu bölümde, ortalama yük değerleri ve işlemci sayısı gibi bilgiler yer alır. MEM: bellek kullanımına ilişkin bilgileri gösterir. SWP: swap belleği kullanımına ilişkin bilgileri gösterir. PAG: bellek yönetimi ile ilgili sayfa hareketlerini (page) gösterir. Bu bölümde, sayfa girişleri (pgin), sayfa çıkışları (pgout) ve öldürülen işlemler (oomkill) gibi bilgiler yer alır. PSI: kaynak basıncını (pressure) ölçen bir araçtır. Bu bölümde, CPU, bellek ve I/O kaynakları üzerindeki basınç seviyeleri yer alır. DSK: disk kullanımına ilişkin bilgileri gösterir. Bu bölümde, disk yoğunluğu (busy), okuma (read) ve yazma (write) işlemleri ve ortalama G/Ç süresi (avio) gibi bilgiler yer alır. NET: ağ kullanımına ilişkin bilgileri gösterir. Bu bölümde, taşıma (transport) ve ağ (network) seviyesindeki veri trafiği ve arayüz (interface) bazında gönderme (send) ve alma (receive) işlemleri yer alır. PID: Sürecin benzersiz kimliği. SYSCPU: Süreç tarafından kullanılan toplam sistem CPU zamanı (saniye). USRCPU: Süreç tarafından kullanılan toplam kullanıcı CPU zamanı (saniye). RDELAY: Sürecin giriş/çıkış (I/O) için beklediği toplam süre (milisaniye). BDELAY: Sürecin bloke edilmesi için beklediği toplam süre (milisaniye). VGROW: Sürecin sanal bellek boyutunda (virtual memory size) büyüdüğü toplam byte sayısı. RGROW: Sürecin RSS (resident set size) boyutunda büyüdüğü toplam byte sayısı. RDDSK: Sürecin diske okuduğu byte sayısı. WRDSK: Sürecin diske yazdığı byte sayısı. RUID: Sürecin gerçek kullanıcı kimliği (real user ID). EUID: Sürecin etkin kullanıcı kimliği (effective user ID). ST: Sürecin durumu (running, sleeping, stopped, zombie vb.). EXC: Sürecin son çıkış kodu (exit code). THR: Sürecin thread (iş parçacığı) sayısı. S: Sürecin çalıştığı sunucu (server). CPUNR: Sürecin çalıştığı CPU numarası. CPU: Sürecin son zaman diliminde kullandığı CPU yüzdesi. CMD: Sürecin komut satırı.  atop farklı şekillerde kullanılabilir.\n -a: Disklerin, CPU\u0026rsquo;nun, belleğin, ağ trafiğinin, süreçlerin ve diğer birçok özelliğin anlık durumunu gösteren tüm sistem özetini sağlar. -m: Bellek kullanımını gösterir. -n: Ağ durumunu gösterir.  Çıktı Kayıt Etme #  atop -w log.atop 2 atop çıktısı her iki saniyede bir log.atop dosyasına yazılır\nKayıt okuma #  atop -r log.atop "},{"id":2,"href":"/linux-training/docs/102/script/bash/","title":"bash script","section":"Script","content":"Bash script nedir? #  Bash scriptler, bir dizi komutu veya bir betiği çalıştıran, Linux veya diğer Unix benzeri işletim sistemlerinde çalışan betiklerdir.\nBash scriptler neden kullanılır? #  Bash scriptler, işlem tekrarlamaları, rutin görevlerin otomatikleştirilmesi, sistem yapılandırmaları, programlama gibi birçok farklı amaçla kullanılabilirler.\nBash script dosyası oluşturma #  Bir bash script dosyası oluşturmak için bir metin editörü kullanabilirsiniz. Örnek bir bash script dosyası adı: \u0026ldquo;my_script.sh\u0026rdquo;\nBash script dosyası izinlerinin ayarlanması #  Bash script dosyasını çalıştırmak için dosyanın çalıştırılabilir olması gerekiyor. Bu nedenle, dosyaya aşağıdaki komutu kullanarak çalıştırma izinleri vermeniz gerekiyor:\nchmod +x my_script.sh Bash script dosyasının ilk satırı #  Bir bash script dosyasının ilk satırı, scriptin hangi kabukta çalışacağını belirtir. Çoğu durumda, ilk satırı \u0026ldquo;#!/bin/bash\u0026rdquo; şeklinde yazmak yeterlidir.\nComment eklemek #  Bash script dosyalarına açıklama eklemek, diğer kullanıcıların dosyanın amacını ve kullanımını anlamalarına yardımcı olabilir. Açıklamalar # işareti ile başlar.\nDeğişkenler #  Bir bash script içinde değişkenler kullanarak birçok görevi yerine getirebilirsiniz. Bir değişken tanımlamak için aşağıdaki gibi bir formül kullanabilirsiniz:\nvariable_name=value Örneğin:\nmessage=\u0026#34;Hello World\u0026#34; echo $message \u0026ldquo;Hello World\u0026rdquo; mesajını ekranda gösterir.\n"},{"id":3,"href":"/linux-training/docs/101/sorun-giderme/dmesg/","title":"dmesg","section":"Sorun Giderme","content":"dmesg, Linux çekirdeği tarafından üretilen sistem günlüğü mesajlarını görüntülemek için kullanılan bir komut satırı aracıdır. \u0026ldquo;dmesg\u0026rdquo; kısaltması, \u0026ldquo;Donanım Mesajı\u0026rdquo; anlamına gelir ve işletim sistemi çekirdeğinin başlangıcından bu yana üretilen tüm günlük mesajlarını görüntüler. Bu mesajlar, donanım hataları, sürücü yüklemeleri, sistem zamanlaması ve diğer sistem olayları hakkında bilgi sağlayabilir. dmesg ayrıca sistemdeki donanım bileşenlerini tanımlamak için de kullanılabilir.\ndmesg komutu aşağıdaki gibi farklı şekillerde kullanılabilir:\n En son sistem logları: dmesg komutu, en son sistem loglarını gösterir.  dmesg  Sistemin loglarını sayfa sayfa göstermek: dmesg komutu, less komutu ile birlikte kullanılarak sayfa sayfa gösterilebilir.  dmesg | less  Sistemin boot mesajlarını görüntülemek: dmesg komutu, dmesg -T seçeneği ile sistemin boot mesajlarını zaman damgalı bir şekilde görüntüleyebilir.  dmesg -T  Dmesg loglarını bir dosyaya kaydetmek: dmesg komutu, çıktısını bir dosyaya yönlendirerek logları kaydedebilir.  dmesg \u0026gt; /home/user/dmesg_logs.txt  Dmesg loglarından sadece error mesajlarını gösterilebilir  dmesg --level=err "},{"id":4,"href":"/linux-training/docs/101/paket-y%C3%B6netimi/dpkg/","title":"DPKG","section":"Paket Yönetimi","content":"dpkg, tek bir paketi veya bir dizi paketi kurmak, kaldırmak, yeniden yapılandırmak, yükseltmek veya sorgulamak için kullanılabilir. Ayrıca, dpkg, sistemde yüklü olan tüm paketlerin listesini de görüntüleyebilir.\ndpkg, önceden hazırlanmış Debian paketlerinin yönetimini sağlar. Bu paketler, .deb uzantılı dosyalar olarak adlandırılır ve Debian veya Ubuntu depolarından indirilebilirler.\ndpkg komutu, aşağıdaki temel işlevleri sağlar:\nPaket kurulumu: \u0026ldquo;dpkg -i paket.deb\u0026rdquo; komutu kullanılarak bir Debian paketi kurulabilir. Paket kaldırma: \u0026ldquo;dpkg -r paket_adı\u0026rdquo; komutu kullanılarak bir Debian paketi kaldırılabilir. Paket güncelleme: \u0026ldquo;dpkg -i paket.deb\u0026rdquo; komutu kullanılarak güncellenmiş bir Debian paketi kurulabilir. Paket bilgisi sorgulama: \u0026ldquo;dpkg -p paket_adı\u0026rdquo; komutu kullanılarak bir paket hakkında bilgi alınabilir. Sistemdeki tüm paketlerin listesi: \u0026ldquo;dpkg \u0026ndash;list\u0026rdquo; komutu kullanılarak tüm yüklü Debian paketleri listelenebilir. dpkg, yalnızca Debian paketlerini yönetmek için kullanılır. dpkg, diğer Linux dağıtımlarında kullanılan paket yöneticilerinden farklı olarak, paket bağımlılıklarını ve bağımlılık yönetimini otomatik olarak yönetmez.\ndpkg -l #  \u0026ldquo;dpkg -l\u0026rdquo; komutu, sisteme yüklenmiş tüm paketleri listelemek için kullanılır.\ndpkg -l $package #  Belirli bir paketin sistemde yüklü olup olmadığını kontrol etmek için kullanılır.\ndpkg -S #  Belirli bir dosyanın hangi pakete ait olduğunu belirlemek için kullanılır. Komutu kullanarak, dosyanın tam yolu veya dosya adını belirtmeniz gerekir.\ndpkg -L #  Bu komutu çalıştırdığınızda, paketin tüm dosyalarının listesi görüntülenecektir. Bu dosyalar arasında, paketin program dosyaları, yapılandırma dosyaları, dokümantasyon dosyaları vb. olabilir.\n"},{"id":5,"href":"/linux-training/docs/102/script/if/","title":"if","section":"Script","content":"if koşulu, bir şartın doğru olup olmadığını kontrol etmek için kullanılır. Örneğin, belirli bir dosya varsa bir komutu çalıştırmak isteyebilirsiniz. Aşağıdaki örnekte, eğer \u0026ldquo;myfile.txt\u0026rdquo; adlı dosya varsa, o zaman \u0026ldquo;dosya var\u0026rdquo; yazdıracak, aksi takdirde \u0026ldquo;dosya yok\u0026rdquo; yazdıracak:\nif [ -f \u0026#34;myfile.txt\u0026#34; ] then  echo \u0026#34;dosya var\u0026#34; else  echo \u0026#34;dosya yok\u0026#34; fi Örnek #  #!/bin/bash # Bu script ile bir sayının tek mi çift mi olduğunu kontrol ediyoruz.  echo \u0026#34;Lütfen bir sayı giriniz: \u0026#34; read sayi  if (( $sayi % 2 == 0 )) then  echo \u0026#34;$sayi sayısı çifttir.\u0026#34; else  echo \u0026#34;$sayi sayısı tektir.\u0026#34; fi Burada, kullanıcının girdiği sayının çift mi tek mi olduğunu kontrol ediyoruz. Girdiğimiz sayıyı 2\u0026rsquo;ye bölümünden kalan 0 ise sayı çift, kalan 1 ise sayı tek olarak değerlendiriliyor. Burada (( )) parantezleri, matematiksel işlemler yapmak için kullanılır.\n"},{"id":6,"href":"/linux-training/docs/102/monitoring/iostat/","title":"iostat","section":"Monitoring","content":"iostat komutu, disk aktivitelerini ve transfer oranlarını, I/O taleplerinin bekleyen sürelerini, CPU kullanım oranlarını ve daha birçok performans istatistiğini görüntüleyebilir. iostat komutu, sistemdeki farklı disklerin performansını ve kullanımını ayrı ayrı gösterir. Bu nedenle, sistem yöneticileri ve sistem performansını izlemek isteyen diğer kullanıcılar tarafından sıkça kullanılır.\niostat, çoğu Linux dağıtımında varsayılan olarak kurulu gelen sysstat paketinin bir parçasıdır. Eğer sisteminizde sysstat paketi yüklü değilse, öncelikle sisteminizdeki paket yöneticisi ile sysstat paketini yüklemeniz gerekmektedir.\nyum install sysstat apt install sysstat örnek iostat çıktısı;\n[root@localhost /]# iostat Linux 6.2.14-300.fc38.x86_64 (localhost.localdomain) 05/06/2023 _x86_64_\t(2 CPU)  avg-cpu: %user %nice %system %iowait %steal %idle  0.25 0.05 0.25 0.03 0.01 99.42  Device tps kB_read/s kB_wrtn/s kB_dscd/s kB_read kB_wrtn kB_dscd vda 2.11 68.77 22.17 0.00 499056 160893 0 zram0 0.04 0.16 0.00 0.00 1176 4 0 Bu çıktıyı yorumlamak gerekirse\n avg-cpu: Sistemin ortalama CPU kullanımını ve bekleme süresini gösterir. %user kullanıcı işlemleri için kullanılan CPU yüzdesini, %system işletim sistemi işlemleri için kullanılan CPU yüzdesini, %idle boşta geçen CPU yüzdesini, %iowait disk girdi/çıktısı için beklenen CPU yüzdesini, %nice öncelikli (nice) kullanıcı işlemleri için kullanılan CPU yüzdesini, %steal sanal işlemcilerin (CPU\u0026rsquo;ların) ana bilgisayarda fiziksel işlemcinin paylaşılması durumunda çaldıkları zaman yüzdesini gösterir.  Device: Bu bölüm, disklerin adını ve istatistiklerini içerir. tps saniyedeki transferlerin (okuma veya yazma) sayısını, kB_read/s ve kB_wrtn/s saniyede okunan ve yazılan kilobayt miktarını, kB_read, kB_wrtn ve kB_dscd toplam okunan, yazılan ve verilerin atıldığı kilobayt miktarını gösterir.\nBu çıktıya göre, sistemin bir disk bölümü (vda) ve bir zram (zram0) disk birimi var. vda saniyede 2.11 transfer gerçekleştiriyor ve saniyede 68.77 kB okuyor ve 22.17 kB yazıyor. zram0 ise çok düşük kullanım oranlarına sahip olduğundan, disk girdi/çıktısı hemen hemen hiç olmuyor.\n"},{"id":7,"href":"/linux-training/docs/102/kernel/kernel/","title":"kernel","section":"Kernel","content":"Linux Kernel, Linux işletim sistemi için temel çekirdek bileşenidir. Linux\u0026rsquo;un temelini oluşturan, donanım kaynaklarını yöneten, işlemleri planlayan, bellek yönetimini sağlayan ve sistem çağrılarını işleyen bir yazılımdır. Linux Kernel, GPL (Genel Kamu Lisansı) altında özgür ve açık kaynaklı bir yazılımdır.\nLinux Kernel, başlangıçta Linus Torvalds tarafından geliştirilmiştir ve şimdi dünya çapında bir geliştirici topluluğu tarafından sürdürülmektedir. Çeşitli platformlar için uygun olan Linux Kernel, dünya genelinde birçok cihazda kullanılmaktadır, özellikle sunucu ve gömülü sistemlerde sıkça kullanılır.\nÇalıştığım bir server da kernel bilgilerine nasıl ulaşabilirim?\n[root@localhost boot]# uname -r 6.2.9-300.fc38.x86_64 veya\n[root@localhost boot]# rpm -q kernel kernel-6.2.9-300.fc38.x86_64 [root@localhost boot]# uname -a Linux localhost.localdomain 6.2.9-300.fc38.x86_64 #1 SMP PREEMPT_DYNAMIC Thu Mar 30 22:32:58 UTC 2023 x86_64 GNU/Linux Bu çıktı, bir Linux işletim sisteminin bazı temel bilgilerini içerir:\n \u0026ldquo;localhost.localdomain\u0026rdquo; hostname\u0026rsquo;dur, yani bu Linux sistemi üzerindeki makinenin adıdır. \u0026ldquo;6.2.9-300.fc38.x86_64\u0026rdquo; kernel sürümüdür. Bu sürüm numarası, sistemin kullandığı Linux kernel\u0026rsquo;in sürümünü gösterir. Bu örnek çıktıda, kernel sürümü \u0026ldquo;6.2.9-300.fc38.x86_64\u0026rdquo; olarak belirtilmiştir. Bu, Fedora 38 için özelleştirilmiş bir kernel sürümüdür. \u0026ldquo;#1 SMP PREEMPT_DYNAMIC Thu Mar 30 22:32:58 UTC 2023\u0026rdquo; bölümü, kernel yapılandırması hakkında bazı bilgileri içerir. Bu örnekte, \u0026ldquo;PREEMPT_DYNAMIC\u0026rdquo; kernel seçeneği etkinleştirilmiştir, bu da öncelikli işlem kuyruğu desteği sunar. Ayrıca, kernelin hangi tarihte ve saatte yapılandırıldığı belirtilir. \u0026ldquo;x86_64 GNU/Linux\u0026rdquo; ise, bu Linux sisteminin mimarisini gösterir. \u0026ldquo;x86_64\u0026rdquo; mimarisi, 64 bit işlemcileri destekleyen bir mimaridir ve bu sistemde kullanılan işlemcinin bu mimariye sahip olduğunu gösterir.  Güncelleme #  Linux çekirdeği kullanan dağıtımlar; test ve kontrollerinden sonra çekirdek versiyonalarını repolarında yayınlamaktadır. Güncelleme komutları ile bu işlemleri gerçekleştirebilirisniz.\n[root@localhost boot]# yum check-update kernel Last metadata expiration check: 0:09:21 ago on Thu 04 May 2023 04:25:04 PM +03. kernel.x86_64 6.2.14-300.fc38 updates [root@localhost boot]# sudo yum install kernel --best Last metadata expiration check: 0:11:10 ago on Thu 04 May 2023 04:25:04 PM +03. Package kernel-6.2.9-300.fc38.x86_64 is already installed. Dependencies resolved. ====================================================================================================== Package Architecture Version Repository Size ====================================================================================================== Installing: kernel x86_64 6.2.14-300.fc38 updates 129 k Installing dependencies: kernel-core x86_64 6.2.14-300.fc38 updates 15 M kernel-modules x86_64 6.2.14-300.fc38 updates 55 M kernel-modules-core x86_64 6.2.14-300.fc38 updates 30 M Transaction Summary ====================================================================================================== Install 4 Packages Total download size: 100 M Installed size: 146 M Is this ok [y/N]: Bu işlemden sonra reboot edip yeni kernel ile oturumu açabilirsiniz.\n"},{"id":8,"href":"/linux-training/docs/102/konteyner/konteyner/","title":"konteyner teknolojisi","section":"Konteyner","content":"Linux konteyner teknolojisi, uygulamaları birbirinden izole edilmiş ortamlarda çalıştırmaya olanak tanıyan bir sanallaştırma teknolojisidir. Konteyner teknolojisi, ana işletim sistemi çekirdeğini paylaşan birden fazla uygulama arasında kaynak kullanımını optimize eder ve uygulamaların hızlı bir şekilde başlatılmasına, dağıtılmasına ve ölçeklendirilmesine olanak tanır.\nKonteyner teknolojisi, konteynerler adı verilen izole edilmiş uygulama ortamları oluşturur. Konteynerler, uygulamaların çalışması için gerekli olan tüm kütüphaneleri, dosyaları ve diğer bağımlılıkları içerir. Her konteyner, bir veya daha fazla işletim sistemi kaynağını kullanır, ancak her konteyner kendi dosya sistemi, ağ arabirimi, bellek ve CPU\u0026rsquo;ya sahiptir. Konteynerler, birbirinden tamamen izole edilmiştir ve bir konteynerin çökmesi, diğer konteynerleri etkilemez.\nKonteyner teknolojisi, Docker ve Kubernetes gibi araçlarla yönetilir. Docker, uygulamaların konteynerlere paketlenmesini, dağıtılmasını ve çalıştırılmasını kolaylaştıran bir platformdur. Kubernetes ise, Docker konteynerlerinin yönetimini otomatikleştirerek, ölçeklendirme, yüksek erişilebilirlik ve yük dengeleme gibi özellikleri sağlar.\nBu diyagramda, tek bir fiziksel sunucuda birden fazla konteynerin nasıl çalıştığı gösterilir. Her konteyner, kendi işletim sistemi kaynağını kullanır ve birden fazla uygulama barındırabilir. Konteynerler, Docker aracılığıyla yönetilir ve Docker Hub gibi kaynaklardan hazır konteyner imajları indirilebilir. Kubernetes ise, birden fazla sunucuda çalışan konteynerlerin yönetimini sağlar.\nKonteyner teknolojisi, uygulama geliştiricilerine, uygulamaları farklı ortamlarda test etme ve dağıtma imkanı sunar. Ayrıca, sistem yöneticileri, konteynerleri farklı sunucular arasında taşıyarak kaynak kullanımını optimize edebilir ve uygulamaların ölçeklendirilmesini kolaylaştırabilir.\n"},{"id":9,"href":"/linux-training/docs/101/kullan%C4%B1c%C4%B1-ve-yetkilendirme/kullan%C4%B1c%C4%B1-olu%C5%9Fturma/","title":"Kullanıcı Oluşturma","section":"Kullanıcı Ve Yetkilendirme","content":"Kullanıcı Oluşturma #  Linux da yeni bir kullanıcı oluşturmak için;\nuseradd new_user Linux\u0026rsquo;ta \u0026lsquo;useradd\u0026rsquo; komutu ile yeni bir kullanıcı eklediğimizde, kilitli bir durumda oluşturulur ve o kullanıcı hesabının kilidini açmak için, \u0026lsquo;passwd\u0026rsquo; komutuyla o hesaba bir şifre belirlememiz gerekir.\n[root@026ddc54726b /]# passwd new_user Changing password for user new_user. New password: Retype new password: passwd: all authentication tokens updated successfully. Parola Atama #  Yeni bir kullanıcı oluşturulduğunda, (şayet yönlendirme yoksa) otomatik olarak \u0026ldquo;/etc/passwd\u0026rdquo; dosyasına eklenir.\n[root@026ddc54726b /]# cat /etc/passwd | grep new_user new_user:x:1000:1000::/home/new_user:/bin/bash Yukarıdaki çıktı, iki nokta üst üste ile ayrılmış yedi alan içerir, her alanın kendi anlamı vardır.\nAlanların Anlamları #  Username: Sisteme giriş yapmak için kullanılan kullanıcı oturum açma adı. 1 ila 32 karakter uzunluğunda olmalıdır. Password: Kullanıcı parolası (veya x karakteri) /etc/shadow dosyasında şifrelenmiş biçimde depolanır. User ID (UID): Her kullanıcının bir Kullanıcı Kimliği (UID) Kullanıcı Kimlik Numarası olmalıdır. Varsayılan olarak, UID 0 root kullanıcı için ayrılmıştır ve 1-99 arasındaki UID\u0026rsquo;ler önceden tanımlanmış diğer hesaplar için ayrılmıştır. 100-999 arasında değişen diğer UID\u0026rsquo;ler, sistem hesapları ve grupları için ayrılmıştır. Group ID (GID): /etc/group dosyasında saklanan birincil Grup Kimliği (GID) Grup Kimlik Numarası. User Info: Bu alan isteğe bağlıdır ve kullanıcı hakkında ekstra bilgiler tanımlamanıza olanak tanır. Home Directory: Kullanıcının ana dizininin mutlak konumu. Shell: Bir kullanıcının kabuğunun mutlak konumu, yani /bin/bash.\nFarklı bir home dizini atayarak oluşturma\nuseradd -d /data/new_user new_user   Farklı bir uid atayarak oluşturma\nuseradd -u 1003 new_user   Farklı gruplara atayarak oluşturma\n[root@026ddc54726b /]# groupadd admins [root@026ddc54726b /]# groupadd db_admins [root@026ddc54726b /]# useradd -G admins,db_admins new_user2 [root@026ddc54726b /]# id new_user2 uid=1001(new_user2) gid=1003(new_user2) groups=1003(new_user2),1001(admins),1002(db_admins)   Home dizini oluşturmadan oluşturma Linux\u0026rsquo;ta yeni bir kullanıcı hesabı oluştururken, kullanıcının otomatik olarak ev dizini (home directory) oluşturulmamasını sağlar. Bu, genellikle sistem hesapları (system accounts) oluşturmak için kullanılır.\n[root@026ddc54726b /]# useradd -M new_user3   "},{"id":10,"href":"/linux-training/docs/101/linux/nedir/","title":"Linux Nedir","section":"Linux","content":"Linux, açık kaynak kodlu bir işletim sistemidir. Bu işletim sistemi, Linus Torvalds tarafından geliştirilmiş ve dünya genelinde birçok geliştirici tarafından desteklenmektedir. Linux, kullanıcılara güvenli, istikrarlı, özgür ve özelleştirilebilir bir işletim sistemi sunar. Bu işletim sistemi, birçok farklı türdeki cihazda kullanılabilir, örneğin bilgisayarlarda, sunucularda, akıllı telefonlarda, tabletlerde ve hatta arabalarda bile kullanılabilir. Linux, birçok farklı dağıtım (distribution) şeklinde mevcuttur ve her bir dağıtım, belirli bir kullanıcı kitlesine yönelik özellikler sunar.\n"},{"id":11,"href":"/linux-training/docs/102/script/listeler/","title":"listeler","section":"Script","content":"Bash script\u0026rsquo;inde listeler, ayrılmış öğelerden oluşan bir dizi gibi davranır. Listeleri oluşturmak için aşağıdaki gibi bir syntax kullanabilirsiniz:\nmy_array=(item1 item2 item3) Listelerdeki öğeler, sıfırdan başlayan bir indeksle erişilir. Örneğin, my_array\u0026rsquo;in ikinci öğesine erişmek için aşağıdaki syntax kullanılabilir:\necho ${my_array[1]} Yeni öğeleri listeye eklemek için, += işlemini kullanabilirsiniz:\nmy_array+=(item4) Öğeleri silmek için, unset komutunu kullanabilirsiniz:\nunset my_array[1] # ikinci öğeyi sil # Bir liste oluşturmak fruits=(elma armut kiraz) echo ${fruits[1]} # armut  # Listeye yeni bir öğe eklemek fruits+=(portakal) echo ${fruits[@]} # elma armut kiraz portakal  # Bir öğe silmek unset fruits[2] echo ${fruits[@]} # elma armut portakal "},{"id":12,"href":"/linux-training/docs/102/monitoring/lsof/","title":"lsof","section":"Monitoring","content":"lsof (list open files) bir sistem aracıdır ve açık dosyaları listelemek için kullanılır. Bu araç, bir sistemde hangi dosyaların açık olduğunu, bu dosyaları hangi kullanıcıların açtığını, hangi proseslerin bu dosyalara eriştiğini ve açık dosyaların hangi bağlantı noktalarına sahip olduğunu görüntülemek için kullanılabilir.\nTüm port ve bağlantıların listelenmesi #  Açık olan tüm network socketleri ve aktif bağlantıları listelemek için -i parametresi kullanılmaktadır.\n lsof -i COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME systemd 1 root 88u IPv6 21068 0t0 TCP *:websm (LISTEN) systemd-r 573 systemd-resolve 10u IPv4 21042 0t0 UDP *:hostmon systemd-r 573 systemd-resolve 11u IPv4 21043 0t0 TCP *:hostmon (LISTEN) systemd-r 573 systemd-resolve 12u IPv6 21045 0t0 UDP *:hostmon systemd-r 573 systemd-resolve 13u IPv6 21046 0t0 TCP *:hostmon (LISTEN) systemd-r 573 systemd-resolve 16u IPv4 21049 0t0 UDP _localdnsstub:domain systemd-r 573 systemd-resolve 17u IPv4 21050 0t0 TCP _localdnsstub:domain (LISTEN) systemd-r 573 systemd-resolve 18u IPv4 21051 0t0 UDP _localdnsproxy:domain systemd-r 573 systemd-resolve 19u IPv4 21052 0t0 TCP _localdnsproxy:domain (LISTEN) chronyd 653 chrony 5u IPv4 24322 0t0 UDP localhost:323 chronyd 653 chrony 6u IPv6 24323 0t0 UDP localhost:323 sshd 1338 root 3u IPv4 28190 0t0 TCP *:ssh (LISTEN) sshd 1338 root 4u IPv6 28199 0t0 TCP *:ssh (LISTEN) sshd 1656 root 4u IPv4 30988 0t0 TCP localhost.localdomain:ssh-\u0026gt;_gateway:46026 (ESTABLISHED) sshd 1660 root 4u IPv4 30988 0t0 TCP localhost.localdomain:ssh-\u0026gt;_gateway:46026 (ESTABLISHED) Görüldüğü gibi dinlenen (LISTEN) tüm portlar ve aktif bağlantılar listelenmektedir.\nEğer, port ve hostname’lerin isim çözümlemesi yapılmadan numerik olarak listelenmesini isterseniz -Pni parametrelerini kullanmanız gerekir:\nlsof -Pni [root@localhost /]# lsof -Pni COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME systemd 1 root 88u IPv6 21068 0t0 TCP *:9090 (LISTEN) systemd-r 573 systemd-resolve 10u IPv4 21042 0t0 UDP *:5355 systemd-r 573 systemd-resolve 11u IPv4 21043 0t0 TCP *:5355 (LISTEN) systemd-r 573 systemd-resolve 12u IPv6 21045 0t0 UDP *:5355 systemd-r 573 systemd-resolve 13u IPv6 21046 0t0 TCP *:5355 (LISTEN) systemd-r 573 systemd-resolve 16u IPv4 21049 0t0 UDP 127.0.0.53:53 systemd-r 573 systemd-resolve 17u IPv4 21050 0t0 TCP 127.0.0.53:53 (LISTEN) systemd-r 573 systemd-resolve 18u IPv4 21051 0t0 UDP 127.0.0.54:53 systemd-r 573 systemd-resolve 19u IPv4 21052 0t0 TCP 127.0.0.54:53 (LISTEN) chronyd 653 chrony 5u IPv4 24322 0t0 UDP 127.0.0.1:323 chronyd 653 chrony 6u IPv6 24323 0t0 UDP [::1]:323 sshd 1338 root 3u IPv4 28190 0t0 TCP *:22 (LISTEN) sshd 1338 root 4u IPv6 28199 0t0 TCP *:22 (LISTEN) sshd 1656 root 4u IPv4 30988 0t0 TCP 192.168.122.151:22-\u0026gt;192.168.122.1:46026 (ESTABLISHED) sshd 1660 root 4u IPv4 30988 0t0 TCP 192.168.122.151:22-\u0026gt;192.168.122.1:46026 (ESTABLISHED) "},{"id":13,"href":"/linux-training/docs/102/kernel/modprobe/","title":"modprobe","section":"Kernel","content":"modprobe, Linux\u0026rsquo;ta bir kernel modülü yüklemek veya kaldırmak için kullanılan bir komuttur. Kernel modülleri, çekirdek içinde çalışan yazılım parçalarıdır ve donanımı yönetmek, sistem kaynaklarını kontrol etmek veya ek özellikler sağlamak gibi görevleri yerine getirirler. Modüller, Linux çekirdeği için dinamik olarak yüklenir ve kaldırılabilirler, bu da gerektiğinde kullanıcılara kernel işlevselliğini genişletme ve yönetme olanağı sağlar.\nlsmod #  Mevcut yüklü kernel modüllerini görüntülemek için lsmod komutunu kullanabilirsiniz. Bu komut, yüklü modüllerin bir listesini ve her bir modül için kullanılan bellek miktarını gösterir. Ayrıca, her modülün kimliğini, adını, boyutunu, kullanılan sayıyı ve kullanıcıları da listeler.\n[root@localhost boot]# lsmod | more Module Size Used by nft_fib_inet 16384 1 nft_fib_ipv4 16384 1 nft_fib_inet nft_fib_ipv6 16384 1 nft_fib_inet nft_fib 16384 3 nft_fib_ipv6,nft_fib_ipv4,nft_fib_inet nft_reject_inet 16384 6 nf_reject_ipv4 16384 1 nft_reject_inet nf_reject_ipv6 24576 1 nft_reject_inet nft_reject 16384 1 nft_reject_inet nft_ct 20480 7 nft_chain_nat 16384 3 nf_nat 65536 1 nft_chain_nat nf_conntrack 192512 2 nf_nat,nft_ct nf_defrag_ipv6 24576 1 nf_conntrack nf_defrag_ipv4 16384 1 nf_conntrack rfkill 40960 1 ip_set 65536 0 nf_tables 348160 189 nft_ct,nft_reject_inet,nft_fib_ipv6,nft_fib_ipv4,nft_chain_nat,nft_r eject,nft_fib,nft_fib_inet nfnetlink 20480 3 nf_tables,ip_set snd_hda_codec_generic 114688 1 ledtrig_audio 16384 1 snd_hda_codec_generic snd_hda_intel 65536 0 snd_intel_dspcfg 36864 1 snd_hda_intel snd_intel_sdw_acpi 20480 1 snd_intel_dspcfg snd_hda_codec 217088 2 snd_hda_codec_generic,snd_hda_intel intel_rapl_msr 20480 0 intel_rapl_common 36864 1 intel_rapl_msr --More-- Modül Oluşturma #  Modül eklemek ve çıkartmak için örnek bir modül oluşturacağız. Bu modül linux çekirdeğine eklendiği zaman \u0026ldquo;hello world\u0026rdquo;, çıkartıldığı zaman \u0026ldquo;by by world\u0026rdquo; yazacak.\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_DESCRIPTION(\u0026#34;Hello world!\u0026#34;); static int __init hello_init(void) { printk(KERN_INFO \u0026#34;Hello world\\n\u0026#34;); return 0; } static void __exit hello_exit(void) { printk(KERN_INFO \u0026#34;bye bye world\\n\u0026#34;); } module_init(hello_init); module_exit(hello_exit); Makefile;\nobj-m = hello-world.o all: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean [root@localhost opt]# ls Makefile sample-module.c [root@localhost opt]# make make -C /lib/modules/6.2.14-300.fc38.x86_64/build M=/opt modules make[1]: Entering directory \u0026#39;/usr/src/kernels/6.2.14-300.fc38.x86_64\u0026#39; warning: the compiler differs from the one used to build the kernel The kernel was built by: gcc (GCC) 13.1.1 20230426 (Red Hat 13.1.1-1) You are using: gcc (GCC) 13.0.1 20230401 (Red Hat 13.0.1-0) CC [M] /opt/sample-module.o MODPOST /opt/Module.symvers CC [M] /opt/sample-module.mod.o LD [M] /opt/sample-module.ko BTF [M] /opt/sample-module.ko Skipping BTF generation for /opt/sample-module.ko due to unavailability of vmlinux make[1]: Leaving directory \u0026#39;/usr/src/kernels/6.2.14-300.fc38.x86_64\u0026#39; [root@localhost opt]# ls Makefile modules.order Module.symvers sample-module.c sample-module.ko sample-module.mod sample-module.mod.c sample-module.mod.o sample-module.o insmod #  insmod Linux işletim sistemi için kullanılan bir komuttur ve \u0026ldquo;insert module\u0026rdquo; kelimelerinin kısaltmasıdır. Bu komut, çalışan bir Linux çekirdeğine yeni bir dinamik yüklenen modülü eklemek için kullanılır.\n[root@localhost opt]# insmod sample-module.ko [root@localhost opt]# dmesg | tail -1 [63572.021553] Hello world dmesg komutu, sistem mesajlarını görüntülemek için \u0026ldquo;kernel ring buffer\u0026rdquo; denilen özel bir bellek bölgesini okur. Bu bellek bölgesi, sistemin başlatılması sırasında ve sonrasında meydana gelen olaylar hakkında ayrıntılı bilgi içerir.\ndmesg komutu, bir terminal penceresine sistem mesajlarını yazdırır ve genellikle sorun giderme veya hata ayıklama işlemlerinde kullanılır.\n rmmod #  rmmod komutu, yüklenmiş bir modülü Linux çekirdeğinden kaldırır ve böylece sistem kaynaklarını serbest bırakır.\n[root@localhost opt]# rmmod sample_module [root@localhost opt]# dmesg | tail -1 [63805.282855] bye bye world "},{"id":14,"href":"/linux-training/docs/102/edit%C3%B6r/nano/","title":"nano","section":"Editör","content":"Nano, terminal tabanlı bir metin editörüdür. Temel olarak Linux ve UNIX işletim sistemlerinde kullanılır. Basit bir kullanıcı arayüzüne sahip olması, yeni kullanıcıların kolayca öğrenip kullanmalarını sağlar. Nano, Vim gibi diğer popüler terminal tabanlı metin editörlerine kıyasla daha az özellik ve daha kolay bir kullanım sunar.\n  Nano\u0026rsquo;yu açmak için terminal açın ve komut satırına \u0026ldquo;nano\u0026rdquo; yazın.\n  Dosyayı açmak için \u0026ldquo;nano dosya_adi\u0026rdquo; yazarak dosyayı açabilirsiniz. Eğer dosya yoksa, Nano yeni bir dosya oluşturur.\n  Dosyayı kaydetmek için Ctrl+O kullanabilirsiniz. Dosya adını yazın ve Enter\u0026rsquo;a basın.\n  Dosyadan çıkmak için Ctrl+X tuşlarına basabilirsiniz. Eğer kaydetmemişseniz, Nano size bir uyarı mesajı gösterecektir.\n  Kelime arama: Ctrl + W tuşlarına basarak açılan arama penceresinde istediğiniz kelimeyi yazabilirsiniz. İleri veya geri arama yapmak için Ctrl + W tuşlarına basıp arama penceresinde Alt + W tuşlarına basarak istediğiniz yönde arama yapabilirsiniz.\n  Satıra gitme: Ctrl + _ tuşlarına basarak açılan satır numarası penceresinde istediğiniz satır numarasını yazabilirsiniz. Ayrıca istediğiniz satıra gitmek için Ctrl + C tuşlarına basarak açılan satır numarası penceresinde Alt + ^ tuşlarına basarak istediğiniz satıra kolayca gidebilirsiniz.\n  "},{"id":15,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/nic/","title":"NIC","section":"Ağ Yönetimi","content":"iproute ve net-tools bu iki paket bize Network kartımız hakkında bilgi verecek ip ve ifconfig komutlarını barındırmaktadır.\nNIC #  NIC (Network Interface Card), ağ arayüz kartı olarak da bilinen bir donanım bileşenidir. Bilgisayar veya diğer cihazlar için ağ bağlantısı sağlar ve kablosuz veya kablolu ağa bağlanmak için kullanılabilir.\nNIC, bir bilgisayarın ağa bağlanmasına izin veren bir ara yüz sağlar. Bir NIC, Ethernet kablosu, fiber optik kablo veya kablosuz ağa bağlanmak için kullanılan antenler gibi fiziksel bağlantı noktaları sağlar. Bu, bilgisayarın ağa erişim sağlamasını ve veri gönderip almasını sağlar.\nNIC\u0026rsquo;ler, birçok farklı boyutta ve şekilde mevcuttur. Bazı NIC\u0026rsquo;ler, PCI veya PCIe gibi bilgisayarın anakartına yerleştirilirken, diğerleri USB veya Thunderbolt bağlantı noktaları aracılığıyla bilgisayara bağlanır.\nNIC\u0026rsquo;ler, ağ işlemleri için donanım hızlandırma sağlayabilir ve ağ trafiği yönetimi, güvenliği ve yönlendirmesi gibi görevleri yürütebilir. NIC\u0026rsquo;ler, ayrıca özel amaçlı görevler için de yapılandırılabilir, örneğin ağ protokolü analizi yapmak için kullanılabilirler.\nip a #  \u0026ldquo;ip a\u0026rdquo; komutu, Linux tabanlı işletim sistemlerinde ağ yapılandırmasını yönetmek için kullanılan bir komuttur. Bu komutun çıktısı, cihazın ağ bağlantılarını, IP adreslerini ve diğer ağ konfigürasyon ayarlarını gösterir.\nörnek çıktı\n[root@026ddc54726b opt]# ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00  inet 127.0.0.1/8 scope host lo  valid_lft forever preferred_lft forever 17: eth0@if18: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default  link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0  inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0  valid_lft forever preferred_lft forever Burada, her bir ağ arayüzü için bir blok görüntülenir. Blok, arayüz adı (örneğin \u0026ldquo;lo\u0026rdquo; veya \u0026ldquo;eth0@if18\u0026rdquo;), durumu, MTU (maksimum iletim birimi) ve diğer bilgileri içerir. Ayrıca, arayüzün IP adresi (inet) ve MAC adresi (link/ether) de görüntülenir.\n\u0026ldquo;BROADCAST, MULTICAST, UP, LOWER_UP\u0026rdquo; ifadeleri, bir ağ arayüzünün durumunu ve özelliklerini tanımlayan farklı bayraklardır.\n  \u0026ldquo;BROADCAST\u0026rdquo; bayrağı, ağ arayüzünün yayın adresini kullanarak diğer cihazlara veri gönderebileceğini gösterir. Bu, cihazın aynı ağda diğer cihazlarla iletişim kurabilmesi için gereklidir.\n  \u0026ldquo;MULTICAST\u0026rdquo; bayrağı, ağ arayüzünün çoklu yayın adreslerini kullanarak diğer cihazlara veri gönderebileceğini gösterir. Bu, özellikle video akışı ve diğer çoklu kullanıcılı uygulamalar için önemlidir.\n  \u0026ldquo;UP\u0026rdquo; bayrağı, ağ arayüzünün etkin olduğunu ve kullanılabilir olduğunu gösterir. Ağ arayüzü, bu bayrağın devre dışı bırakılmasıyla devre dışı bırakılabilir.\n  \u0026ldquo;LOWER_UP\u0026rdquo; bayrağı, ağ arayüzünün fiziksel olarak bağlı olduğunu gösterir. Yani kablo bağlandığında ağ arayüzü otomatik olarak etkinleştirilir ve \u0026ldquo;LOWER_UP\u0026rdquo; bayrağı ayarlanır.\n  ifconfig #  \u0026ldquo;ifconfig\u0026rdquo; komutu, Unix tabanlı işletim sistemlerinde ağ arayüzlerinin yapılandırması ve yönetimi için kullanılan bir komuttur. Bu komutun çıktısı, cihazın ağ arayüzlerinin durumunu, IP adreslerini, MAC adreslerini ve diğer ağ yapılandırma bilgilerini gösterir.\nörnek çıktı\n[root@026ddc54726b opt]# ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255  ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet)  RX packets 69518 bytes 102955785 (98.1 MiB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 36460 bytes 2495651 (2.3 MiB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Bu çıktıda, \u0026ldquo;eth0\u0026rdquo; adlı ağ arayüzü için bilgiler görüntülenir. Ağ arayüzü hakkındaki bilgiler, bayraklar, MTU (maksimum iletim birimi), IP adresi, alt ağ maskesi, yayın adresi ve MAC adresi gibi çeşitli bölümlerde ayrılır.\nAyrıca, RX (alınan) ve TX (gönderilen) paketlerinin sayısı ve boyutu da görüntülenir. Bu bölümlerde, RX hataları, düşürülen paketler ve diğer sorunlar hakkında da bilgi alınabilir. Benzer şekilde, TX hataları, düşürülen paketler, taşıyıcı hataları ve çakışmalar hakkında da bilgi alınabilir.\nBu çıktı, ağ arayüzünün durumu, yapılandırması ve performansı hakkında bilgi sağlar ve sorun giderme işlemleri sırasında kullanışlı bir araçtır.\n"},{"id":16,"href":"/linux-training/docs/101/paket-y%C3%B6netimi/rpm/","title":"RPM","section":"Paket Yönetimi","content":"RPM (Red Hat Package Manager), Linux işletim sistemi için bir paket yönetim sistemidir. RPM, Red Hat ve diğer bazı Linux dağıtımları tarafından kullanılır ve paketlerin kurulumu, kaldırılması, güncellenmesi ve yönetimi için kullanılır.\nRPM, paketlerin dosya sistemine nasıl yerleştirileceği ve kurulum sırasında hangi diğer paketlerin gereksinimlerinin karşılanacağı gibi konuları ele alır. Ayrıca paketlerin diğer sistemlerle uyumlu olup olmadığını kontrol eder ve uyumsuzluk durumunda uygun hataları rapor eder.\nRPM, özellikle sunucu sistemleri gibi büyük ve karmaşık Linux sistemlerinde kullanımı yaygındır. RPM paketleri, yazılım geliştiricileri tarafından oluşturulabilir ve ayrıca çeşitli depolardan indirilebilir. RPM ayrıca, özellikle Red Hat ve Fedora gibi bazı Linux dağıtımları için yazılım güncelleme araçları tarafından da kullanılır.\nrpm -qa #  Komutu, sisteme yüklenmiş tüm RPM paketlerinin listesini görüntülemek için kullanılır. Bu komut, kurulu olan tüm paketlerin isimlerini, sürümlerini ve yayıncılarını gösterir.\n[ergunbilsel@localhost linux-101]$ rpm -qa khmeros-fonts-common-5.0-30.fc33.noarch adwaita-qt4-1.1.3-4.fc33.x86_64 gpg-pubkey-9570ff31-5e3006fb rpm -q #  Belirli bir RPM paketinin sistemde yüklü olup olmadığını kontrol etmek için kullanılır. Bu komut, paket adını belirtilen bir argüman olarak alır ve paketin adını, sürümünü ve yayıncısını görüntüler.\n[ergunbilsel@localhost linux-101]$ rpm -q adwaita-qt4-1.1.3-4.fc33.x86_64 adwaita-qt4-1.1.3-4.fc33.x86_64 [ergunbilsel@localhost linux-101]$ rpm -q adwaita-qt4-1.1.3-4.fc33.x86_6 adwaita-qt4-1.1.3-4.fc33.x86_6 paketi kurulu değil rpm -Uvh #  Yeni bir RPM paketini yüklemek veya mevcut bir paketi güncellemek için kullanılır. Bu komut, aşağıdaki üç adımı gerçekleştirir:\n Paketi yüklemek veya güncellemek için gerekli izinleri kontrol eder. Var olan bir paketin yerine yeni bir sürümü yükler. Yeni paketin kurulumunu tamamlar ve kurulum işlemi sırasında ayrıntılı çıktılar gösterir.  \u0026ldquo;U\u0026rdquo; seçeneği, güncelleştirme işlemi için kullanılırken, \u0026ldquo;h\u0026rdquo; seçeneği, işlem sırasında ilerlemeyi gösteren ayrıntılı bir çıktı sağlar. \u0026ldquo;v\u0026rdquo; seçeneği ise, yüklenen veya güncellenen paketlerle ilgili daha fazla ayrıntı sağlar.\n[ergunbilsel@localhost linux-101]$ sudo rpm -Uvh pam_ssh-2.3-12.fc37.x86_64.rpm [sudo] password for ergunbilsel: Verifying... ################################# [100%] Hazırlanıyor... ################################# [100%] Güncelleniyor / kuruluyor...  1:pam_ssh-2.3-12.fc37 ################################# [100%] [ergunbilsel@localhost linux-101]$ rpm -e #  RPM paketini kaldırmak için kullanılır. Bu komut, sisteme yüklenmiş olan bir paketi kaldırır ve sistemden tüm paket dosyalarını ve yapılandırma dosyalarını siler.\nKomut, kaldırılacak paketin adını argüman olarak alır. Örneğin, \u0026ldquo;rpm -e myapp\u0026rdquo; komutu, \u0026ldquo;myapp\u0026rdquo; adlı bir paketi kaldırır.\nEğer kaldırılmak istenen paket, başka bir paket tarafından kullanılıyorsa, \u0026ldquo;rpm\u0026rdquo; komutu bir hata mesajı verebilir. Bu durumda, kaldırılacak paketi kullanan diğer paketlerin de önce kaldırılması gerekebilir.\n[ergunbilsel@localhost linux-101]$ sudo rpm -e pam_ssh /var/lib/rpm #  Red Hat tabanlı Linux sistemlerinde RPM paket yöneticisinin kullandığı veritabanı dosyalarının depolandığı dizindir. Bu dizin, RPM paketlerinin yüklü olduğu ve kaldırıldığı hakkında bilgiyi içeren bir veritabanı dosyası olan \u0026ldquo;Packages\u0026rdquo; dosyasını ve paket imza anahtarlarının depolandığı birkaç diğer veritabanı dosyasını içerir.\nBu dizin ayrıca, RPM paket yöneticisinin veritabanına erişmek için kullandığı diğer veritabanı dosyalarını da içerir. Bu dosyaların bazıları, imza anahtarları ve önbellek dosyalarını depolar.\n\u0026ldquo;/var/lib/rpm\u0026rdquo; dizini, RPM paketlerinin yönetimi için önemli bir rol oynar ve bu nedenle, bu dizinin izinleri ve bütünlüğü dikkatlice korunmalıdır. Ayrıca, RPM paketleri elle düzenlenmeden önce, bu dizin ve alt dizinlerindeki dosyaların yedeklenmesi önerilir.\n[ergunbilsel@localhost linux-101]$ cd /var/lib/rpm [ergunbilsel@localhost rpm]$ ls rpmdb.sqlite rpmdb.sqlite-shm rpmdb.sqlite-wal Bir RPM Paketinin İçeriği  yum #  Red Hat tabanlı Linux dağıtımlarında kullanılan bir paket yöneticisidir. Yum, RPM paket yöneticisinin üzerine inşa edilmiştir ve RPM paketlerini indirme, kurma, güncelleştirme ve kaldırma işlemlerini gerçekleştirebilir. Yum (Yellowdog Updater, Modified) ayrıca, sistemdeki paketlerin bağımlılıklarını çözer ve yeni bir paket yüklemek istendiğinde, gerekli diğer paketleri otomatik olarak indirir.\n[ergunbilsel@localhost linux-101]$ cd /var/lib/rpm [ergunbilsel@localhost rpm]$ ls rpmdb.sqlite rpmdb.sqlite-shm rpmdb.sqlite-wal yum list #  [ergunbilsel@localhost rpm]$ yum list | wc -l Error: \u0026#39;virtualbox\u0026#39; deposu için üst veriler indirilemedi: repomd.xml GPG signature verification error: Bad GPG signature Depolar yok sayılıyor: virtualbox 70733 Bir repo silelim\n[ergunbilsel@localhost static]$ yum repolist depo id depo ismi Mongodb MongoDB Repository anydesk AnyDesk Fedora - stable docker-ce-stable Docker CE Stable - x86_64 fedora Fedora 37 - x86_64 fedora-cisco-openh264 Fedora 37 openh264 (From Cisco) - x86_64 fedora-modular Fedora Modular 37 - x86_64 google-chrome google-chrome opera Opera packages rpmfusion-free RPM Fusion for Fedora 37 - Free rpmfusion-free-updates RPM Fusion for Fedora 37 - Free - Updates rpmfusion-nonfree RPM Fusion for Fedora 37 - Nonfree rpmfusion-nonfree-updates RPM Fusion for Fedora 37 - Nonfree - Updates slack slack teams teams teamviewer TeamViewer - x86_64 updates Fedora 37 - x86_64 - Updates updates-modular Fedora Modular 37 - x86_64 - Updates virtualbox Fedora - - VirtualBox Öncelikle mevcut repo listesini görüntüliyelim\nyum-config-manager \u0026ndash;disable #  [ergunbilsel@localhost static]$ sudo yum-config-manager --disable virtualbox [ergunbilsel@localhost static]$ yum repolist depo id depo ismi Mongodb MongoDB Repository anydesk AnyDesk Fedora - stable docker-ce-stable Docker CE Stable - x86_64 fedora Fedora 37 - x86_64 fedora-cisco-openh264 Fedora 37 openh264 (From Cisco) - x86_64 fedora-modular Fedora Modular 37 - x86_64 google-chrome google-chrome opera Opera packages rpmfusion-free RPM Fusion for Fedora 37 - Free rpmfusion-free-updates RPM Fusion for Fedora 37 - Free - Updates rpmfusion-nonfree RPM Fusion for Fedora 37 - Nonfree rpmfusion-nonfree-updates RPM Fusion for Fedora 37 - Nonfree - Updates slack slack teams teams teamviewer TeamViewer - x86_64 updates Fedora 37 - x86_64 - Updates updates-modular Fedora Modular 37 - x86_64 - Updates   yum search #  YUM paket yöneticisi komutudur ve kullanıcılara, bir veya daha fazla anahtar kelime kullanarak, mevcut paket depolarında arama yapma imkanı sağlar.\n[ergunbilsel@localhost static]$ yum search python3.8 ========================================================== Ad Tam Olarak Eşleşti: python3.8 ========================================================== python3.8.x86_64 : Version 3.8 of the Python interpreter python3.8.i686 : Version 3.8 of the Python interpreter Örneğin, \u0026ldquo;yum search python3.8\u0026rdquo; komutu, mevcut depolarda \u0026ldquo;python3.8\u0026rdquo; anahtar kelimesini içeren tüm paketleri listeleyecektir. Eğer bir paket adı tam olarak bilinmiyorsa, bu komut arama sonuçlarında paket adının bir parçasını da arayabilir.\nyum provides #  Paket yöneticisi komutudur ve belirli bir dosyanın hangi pakete ait olduğunu belirlemek için kullanılır.\n[ergunbilsel@localhost static]$ yum provides git git-2.37.3-1.fc37.x86_64 : Fast Version Control System Depo : fedora Şuradan eşleşti: Sağlayıcı : git = 2.37.3-1.fc37 yum install #  Belirtilen paketi veya paketleri yüklemek için kullanılır.\nÖrneğin, \u0026ldquo;yum install firefox\u0026rdquo; komutu, \u0026ldquo;firefox\u0026rdquo; paketini yükler.\nyum update #  Yüklü tüm paketleri en son sürümlerine güncellemek için kullanılır.\nYUM, paketleri güncelleme işlemi sırasında bağımlılıkları da kontrol eder ve gerektiğinde ilgili paketleri yükleyerek güncelleme işlemini tamamlar. Bu nedenle, \u0026ldquo;yum update\u0026rdquo; komutu, sistemdeki tüm paketleri güncellemek için yaygın bir kullanım şeklidir.\nyum grouplist #  Yüklü ve kullanıma hazır paket gruplarını ve alt gruplarını listelemek için kullanılır.\n[ergunbilsel@localhost static]$ yum grouplist Son üst veri süresi sona erme denetimi: 2:52:44 önce, Çrş 26 Nis 2023 11:26:03 tarihinde. Kullanılabilir Ortam Grupları:  Fedora Özel İşletim Sistemi  Asgari Kurulum  Fedora Sunucu Sürümü  Fedora İş İstasyonu  Fedora Bulut Sunucu  KDE Plasma Çalışma Alanları  Xfce Masaüstü  LXDE Masaüstü  LXQt Masaüstü  Cinnamon Masaüstü  MATE Masaüstü  Sugar Masaüstü Ortamı  Deepin Masaüstü  Budgie Desktop  Geliştirme ve Yaratıcılık İş İstasyonu  Web Sunucusu  Alt Yapı Sunucusu  i3 desktop Kurulu Ortam Grupları:  Temel Masaüstü Kurulu Gruplar:  Konteyner Yönetimi  Geliştirme Araçları  LibreOffice  GNOME  Fontlar  Donanım Desteği Kullanılabilir Gruplar:  3B Yazdırma  Yönetim Araçları  Ses Üretimi  Yazım ve Yayım  Budgie  Budgie Desktop Applications  C Geliştirme Araçları ve Kütüphaneleri  Bulut Alt Yapısı  Bulut Yönetim Araçları  Compiz  D Geliştirme Araçları ve Kütüphaneleri  Tasarım Takımı  Etki Alanı Üyeliği  Metin Düzenleyiciler  Eğitim Yazılımı  Elektronik Laboratuvarı  Mühendislik ve Bilim  FreeIPA Sunucusu  Başsız Yönetim  MATE Uygulamaları  Milkymist  Ağ Sunucuları  Nöron Modelleme Simülatörleri  Ofis/Verimlilik  Python Sınıfı  Bilimsel Python  Robotik  RPM Geliştirme Araçları  Güvenlik Laboratuvarı  Metin tabanlı İnternet  Pencere Yöneticileri  Deepin Masaüstü Ortamı  Grafiksel İnternet  KDE  Oyunlar ve Eğlencelik  Ses ve Görüntü  Sistem Araçları \u0026ldquo;yum grouplist\u0026rdquo; komutu, sistemde hangi paket gruplarının mevcut olduğunu anlamak için faydalıdır. Ancak, tüm paket grupları hakkında ayrıntılı bilgi almak isteyen kullanıcılar, \u0026ldquo;yum groupinfo [grup adı]\u0026rdquo; komutunu kullanarak daha fazla bilgi alabilirler.\n[ergunbilsel@localhost linux-101]$ yum groupinfo GNOME Grup: GNOME  Tanım: GNOME son derece sezgisel ve kullanıcı dostu bir masaüstü ortamıdır.  Zorunlu Paketler:  dconf  gdm  gnome-boxes  gnome-connections  gnome-control-center  gnome-initial-setup  gnome-session-wayland-session  gnome-session-xsession  gnome-settings-daemon  gnome-shell  gnome-software  gnome-terminal  gnome-text-editor  nautilus  polkit  yelp  Öntanımlı Paketler:  ModemManager  NetworkManager-adsl  NetworkManager-openconnect-gnome  NetworkManager-openvpn-gnome  NetworkManager-ppp  NetworkManager-pptp-gnome  NetworkManager-ssh-gnome  NetworkManager-vpnc-gnome  NetworkManager-wwan  PackageKit-command-not-found  PackageKit-gtk3-module  adobe-source-code-pro-fonts  at-spi2-atk  at-spi2-core  avahi  baobab  cheese  eog  evince  evince-djvu  evince-nautilus  fprintd-pam  glib-networking  gnome-backgrounds  gnome-bluetooth  gnome-browser-connector  gnome-calculator  gnome-calendar  gnome-characters  gnome-classic-session  gnome-clocks  gnome-color-manager  gnome-contacts  gnome-disk-utility  gnome-font-viewer  gnome-logs  gnome-maps  gnome-photos  gnome-remote-desktop  gnome-system-monitor  gnome-terminal-nautilus  gnome-themes-extra  gnome-user-docs  gnome-user-share  gnome-weather  gvfs-afc  gvfs-afp  gvfs-archive  gvfs-fuse  gvfs-goa  gvfs-gphoto2  gvfs-mtp  gvfs-smb  libcanberra-gtk3  libproxy-duktape  librsvg2  libsane-hpaio  mesa-dri-drivers  mesa-libEGL  orca  rygel  sane-backends-drivers-scanners  simple-scan  sushi  systemd-oomd-defaults  totem  tracker  tracker-miners  xdg-desktop-portal  xdg-desktop-portal-gnome  xdg-desktop-portal-gtk  xdg-user-dirs-gtk  İsteğe Bağlı Paketler:  vlc Repolar #  Örnek bir repo taslağı\n[$repo] name=My Repository baseurl=http://path/to/MyRepo gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-MyRep "},{"id":17,"href":"/linux-training/docs/security/shadow/","title":"shadow","section":"Security","content":"/etc/shadow dosyası, Linux işletim sistemlerinde kullanıcıların şifrelerinin şifrelenmiş halinin tutulduğu dosyadır. Bu dosya, /etc/passwd dosyasındaki kullanıcıların şifrelerinin tutulduğu satırların yerine gelir ve kullanıcı şifrelerini şifreleyerek saklar. Şifreleme, genellikle MD5, SHA256 veya Blowfish algoritmaları kullanılarak yapılır.\n/etc/shadow dosyası genellikle sadece root kullanıcısı tarafından okunabilir ve düzenlenebilir. Bu sayede, sadece sistem yöneticisi tarafından erişilebilen şifrelerin güvenliği artırılmış olur.\n/etc/shadow dosyasında her satır bir kullanıcıya aittir ve özellikleri iki nokta üst üste (:) karakteri ile ayrılmış beş alan ile tanımlanır:\nroot:$6$TS/VWbU6$eoU6A.YPS2fNUjhroKXayX9.3CswlrUvL8pHyiUisR16UwXd6oOJQmkZlC0I9Xc3li3/lbKvzK1dIFN5xIw1r0:18603:0:99999:7::: Yukarıdaki çıktıda /etc/shadow dosyasında \u0026ldquo;root\u0026rdquo; kullanıcısına ait hashlenmiş şifre ve diğer bazı kullanıcı özelliklerini içermektedir.\n root: Bu kullanıcının adıdır. $6$TS/VWbU6$eoU6A.YPS2fNUjhroKXayX9.3CswlrUvL8pHyiUisR16UwXd6oOJQmkZlC0I9Xc3li3/lbKvzK1dIFN5xIw1r0: kullanıcının hashlenmiş şifresidir. $6$ burada kullanılan hash türünü belirtir (SHA-512), TS/VWbU6 ise salt değerini belirtir ve son kısım ise hashlenmiş şifrenin kendisidir. 18603: Bu kullanıcının son şifre değiştirme tarihini ifade eder. Bu, 1970 yılından bu yana geçen gün sayısını (Unix zaman damgası) gösterir. 0: Bu kullanıcının şifre değiştirme süresini ifade eder. 0, herhangi bir kısıtlama olmadığı anlamına gelir. 99999: Bu kullanıcının hesabının ne zaman süresinin dolduğunu gösterir. 99999, hesabın hiçbir zaman süresinin doldurulmayacağı anlamına gelir. 7: Bu kullanıcının şifre değiştirme hatırlatma süresini ifade eder. 7, kullanıcının şifre değiştirmesi için hatırlatılacağı gün sayısını gösterir. :: : Bu alan kullanılmaz, ancak eski bir parolaya sahip olan kullanıcılar için kullanılır. Şifre değiştirme zamanı dolduğunda, eski şifre burada saklanır.  "},{"id":18,"href":"/linux-training/docs/102/script/s%C3%B6zl%C3%BCkler/","title":"sözlükler","section":"Script","content":"Bash script\u0026rsquo;inde sözlükler, anahtar-değer çiftlerinden oluşan bir yapıdır. Sözlükler oluşturmak için aşağıdaki gibi bir syntax kullanabilirsiniz:\ndeclare -A my_dict # -A seçeneği, bir sözlük oluşturur my_dict=([key1]=value1 [key2]=value2 [key3]=value3) Yeni bir öğe eklemek için, aşağıdaki gibi bir syntax kullanabilirsiniz:\nmy_dict[key4]=value4 Bir öğe silmek için, unset komutunu kullanabilirsiniz:\nunset my_dict[key2] Bir sözlükteki tüm anahtarları veya tüm değerleri almak için, ! işaretini kullanabilirsiniz:\necho ${!my_dict[@]} # tüm anahtarları alır echo ${my_dict[@]} # tüm değerleri alır # Bir sözlük oluşturmak declare -A colors colors=([red]=FF0000 [green]=00FF00 [blue]=0000FF) echo ${colors[green]} # 00FF00  # Bir öğe eklemek colors[yellow]=FFFF00 echo ${colors[@]} # FF0000 00FF00 0000FF FFFF00  # Bir öğe silmek unset colors[blue] echo ${colors[@]} # FF0000 00FF00 FFFF00  # Tüm anahtarları almak echo ${!colors[@]} # red green yellow "},{"id":19,"href":"/linux-training/docs/102/remote-connection/ssh/","title":"ssh","section":"Remote Connection","content":"SSH, Secure Shell\u0026rsquo;in kısaltmasıdır ve güvenli bir uzak erişim protokolüdür. SSH, şifreli bir bağlantı sağlayarak bilgisayarınıza uzaktan erişim sağlar ve verilerinizi şifreler. Ayrıca SSH, dosya transferleri, X11 bağlantıları ve TCP bağlantıları için de kullanılabilir.\nSSH, Linux ve Unix işletim sistemlerinde bulunur ve aynı zamanda birçok Windows sistemlerinde de kullanılabilir. Ayrıca, birçok bulut sunucu sağlayıcısı da SSH erişimi sağlar.\nBirçok Linux/Unix dağıtımında, SSH varsayılan olarak kurulu olarak gelir. Ancak, bir nedenle SSH kurulu değilse, şu adımları izleyerek kurabilirsiniz:\nSSH paketini yükleyin:\n Debian/Ubuntu: sudo apt-get install openssh-server CentOS/Fedora: sudo yum install openssh-server  SSH servisini başlatın:\n Debian/Ubuntu: sudo service ssh start CentOS/Fedora: sudo systemctl start sshd.service  SSH servisini otomatik olarak başlatmak için:\n Debian/Ubuntu: sudo update-rc.d ssh defaults CentOS/Fedora: sudo systemctl enable sshd.service  SSH Port Değiştirme: #  SSH bağlantısı için varsayılan olarak 22 numaralı port kullanılır. Ancak bu, güvenlik açısından risk teşkil edebilir çünkü kötü amaçlı kullanıcılar tarafından bilinen bir porttur. Bu nedenle, SSH bağlantı noktasını değiştirmek, bilgisayarınızın daha güvende olmasına yardımcı olabilir.\nÖncelikle, herhangi bir metin düzenleyicisi (nano, vi, gibi) kullanarak /etc/ssh/sshd_config dosyasını açın:\n nano /etc/ssh/sshd_config Dosya açıldığında, \u0026ldquo;Port\u0026rdquo; satırını bulun ve 22 numarasını, güvendiğiniz bir başka port numarası ile değiştirin. Örneğin, 2222 olarak değiştirebilirsiniz.\nPort 2222 Değişikliği kaydedin ve dosyayı kapatın.\nSon olarak, SSH servisini yeniden başlatın.\nsystemctl restart sshd SSH Anahtar Eşleştirme: #  SSH anahtar eşleştirme, kullanıcıların şifreleri yerine anahtarlarını kullanarak güvenli bir şekilde oturum açmasını sağlar. Bu, güvenliği arttırır ve oturum açma işlemini hızlandırır.\nÖncelikle, anahtar çiftini oluşturmak için ssh-keygen komutunu kullanın.\nssh-keygen Karşınıza \u0026ldquo;Enter file in which to save the key\u0026rdquo; şeklinde bir soru çıkacaktır. Sadece \u0026ldquo;Enter\u0026rdquo; tuşuna basın.\nKarşınıza \u0026ldquo;Enter file in which to save the key\u0026rdquo; şeklinde bir soru çıkacaktır. Sadece \u0026ldquo;Enter\u0026rdquo; tuşuna basın.\nŞimdi, bir parola belirleyin (opsiyonel) ve iki kez onaylayın.\nAnahtar çifti oluşturulduktan sonra, public key\u0026rsquo;i sunucuya göndermeniz gerekiyor. Bunun için ssh-copy-id komutunu kullanın.\nssh-copy-id username@remote_host Kullanıcı adını ve uzak sunucunun adresini belirtin ve parolayı girin.\nArtık SSH anahtar eşleştirme kurulmuştur. SSH anahtar eşleştirme, şifreleri kullanmadan oturum açmanıza izin verecektir.\nSSH Güvenlik Ayarları: #  SSH güvenliğini arttırmak için aşağıdaki adımları uygulayabilirsiniz.\nRoot kullanıcısının SSH erişimini engelleyin. Bu, bir saldırganın direkt olarak root hesabına saldırmasını önleyecektir.\nnano /etc/ssh/sshd_config PermitRootLogin no Şifre tabanlı kimlik doğrulamayı devre dışı bırakma:\nŞifre tabanlı kimlik doğrulama, kullanıcı adı ve şifre kullanarak kimlik doğrulamayı içerir. Ancak, bu yöntem güvenli değildir ve şifrelerin kolayca çalınabileceği riski vardır. Bunun yerine, anahtar tabanlı kimlik doğrulamayı kullanmak daha güvenlidir. Anahtar tabanlı kimlik doğrulama, bir kullanıcının bir anahtar çifti oluşturmasını ve anahtarın bir kopyasını sunucuya yüklemesini içerir. Kullanıcı daha sonra anahtarını kullanarak kimlik doğrulama yapabilir.\nŞifre tabanlı kimlik doğrulamayı devre dışı bırakmak için ilgili satırları yorum satırına çevirin veya silebilirsiniz. Örneğin:\n#PasswordAuthentication yes SSH sunucusunu yeniden başlatın:\nsystemctl restart sshd IP tabanlı erişim kontrolü:\nSSH sunucusuna kimlerin erişebileceğini sınırlamak için IP tabanlı erişim kontrolü yapılabilir. Bu, belirli bir IP adresi aralığına veya tek bir IP adresine erişim sağlamak için kullanılabilir.\nAllowUsers\u0026quot; veya \u0026ldquo;AllowGroups\u0026rdquo; ayarlarını kullanarak belirli IP adreslerine erişim izni verebilirsiniz. Örneğin, aşağıdaki satırı ekleyerek belirli bir IP adresine erişim izni verebilirsiniz:\nAllowUsers user1@192.168.0.100 Bu ayar, yalnızca \u0026ldquo;user1\u0026rdquo; kullanıcısının \u0026ldquo;192.168.0.100\u0026rdquo; IP adresinden SSH sunucusuna erişmesine izin verir.\nSadece bir kullanıcıyı engellemek isterseniz;\nDenyUsers user1@192.168.0.100 "},{"id":20,"href":"/linux-training/docs/102/systemd/servis/","title":"systemd operasyonları","section":"Systemd","content":"Systemd, modern Linux sistemlerinde başlatma ve durdurma işlemlerinin yönetimini sağlayan bir sistem yönetimi aracıdır. Systemd, birim dosyaları olarak adlandırılan yapılandırma dosyaları kullanarak sistem hizmetlerini yönetir. Bu birim dosyaları, hizmetin başlatma, durdurma, yeniden başlatma, devreye alma ve devre dışı bırakma gibi işlemlerini yönetmek için komutlar sağlar.\nSystemd ile kullanılan en temel işlemler şunlardır:\n start: Bir hizmeti başlatmak için kullanılır. Örnek kullanım:  systemctl start nginx.service Bu komut, nginx hizmetini başlatır.\n stop: Bir hizmeti durdurmak için kullanılır. Örnek kullanım:  systemctl stop nginx.service Bu komut, nginx hizmetini durdurur.\n restart: Bir hizmeti yeniden başlatmak için kullanılır. Örnek kullanım:  systemctl restart nginx.service Bu komut, nginx hizmetini yeniden başlatır.\n enable: Bir hizmeti başlangıçta otomatik olarak başlatmak için kullanılır. Örnek kullanım:  systemctl enable nginx.service Bu komut, nginx hizmetinin sistem başlangıcında otomatik olarak başlatılmasını sağlar.\n disable: Bir hizmeti başlangıçta otomatik olarak başlatmayı devre dışı bırakmak için kullanılır.  systemctl disable nginx.service Bu komut, nginx hizmetinin sistem başlangıcında otomatik olarak başlatılmasını engeller.\n"},{"id":21,"href":"/linux-training/docs/101/komutlar/kabuk-komut/","title":"Temel komutlar","section":"Komutlar","content":"Linux, bir işletim sistemi olarak, bilgisayar donanımını yönetir ve kullanıcıların bilgisayar kaynaklarını (dosyalar, yazılımlar, cihazlar vb.) yönetmelerine olanak tanır. Linux, çekirdek olarak adlandırılan temel bir bileşene sahiptir ve bu çekirdek, işletim sistemi işlevlerini yerine getirmek için kullanılır. Linux\u0026rsquo;un çalışması için, bir bilgisayarda öncelikle BIOS (Basic Input/Output System) adı verilen bir yazılım yüklü olmalıdır. BIOS, bilgisayarın temel işlevlerini sağlar, örneğin sabit disk, klavye ve fare gibi bileşenlere erişim sağlar.\nDaha sonra, bilgisayarın işletim sistemi yüklenebilmesi için bir önyükleme işlemi gerçekleştirilir. Bu işlemde, bilgisayar önce BIOS tarafından yönlendirilir, ardından işletim sistemi önyükleyicisi olarak adlandırılan bir yazılım yüklenir. Önyükleyici, işletim sisteminin yüklenmesi için gereken dosyaları bulmak ve yüklemek için gerekli adımları atar. İşletim sistemi yüklendikten sonra, kullanıcı bir kabuk (shell) aracılığıyla işletim sistemini yönetebilir. Kabuk, kullanıcının komutlar yazmasını ve işletim sistemi ile etkileşimde bulunmasını sağlar. Bash (Bourne-Again SHell) kabuğu, Linux sistemlerinde en yaygın olarak kullanılan kabuktur.\nAyrıca, bir Linux sistemi için önyükleme sürecinde önemli bir bileşen olan GRUB (Grand Unified Bootloader) önyükleme yükleyicisini de ekleyebiliriz. GRUB, bilgisayarın önyükleme işlemi sırasında işletim sistemi yükleyicisini bulmak ve yüklemek için kullanılır. Ayrıca, birden fazla işletim sistemi varsa, kullanıcının hangi işletim sistemi yüklemesini seçebileceği bir menü sunar. Sonuç olarak, Linux, bir işletim sistemi olarak, donanım, önyükleme işlemi, GRUB, kabuk ve işletim sistemi yükleyicisi gibi bileşenleri içeren bir bütündür. Bu bileşenler birbirleriyle etkileşime girerek, kullanıcıların bilgisayar kaynaklarını yönetmesine olanak tanır.\nKomutlar #  ls #  Bu komut, bulunduğunuz dizinin içeriğini listeler. Örneğin, ls komutunu çalıştırdığınızda dizindeki dosyalar ve diğer dizinler listelenecektir.\ncd #  Bu komut, bir dizinden diğerine geçmenizi sağlar. Örneğin, cd /home komutu, bulunduğunuz dizinden /home dizinine geçmenizi sağlar.\npwd #  Bu komut, bulunduğunuz dizinin tam yolunu gösterir. Örneğin, pwd komutu, bulunduğunuz dizinin tam yolunu görüntüler.\nmkdir #  Bu komut, yeni bir dizin oluşturmanızı sağlar. Örneğin, mkdir myfolder komutu, bulunduğunuz dizinde myfolder adında yeni bir dizin oluşturur.\nrmdir #  Bu komut, boş bir dizini silmenizi sağlar. Örneğin, rmdir myfolder komutu, myfolder adındaki boş dizini siler.\nrm #  Bu komut, bir dosya veya dizini silmenizi sağlar. Örneğin, rm myfile.txt komutu, myfile.txt adındaki dosyayı siler.\ncp #  Bu komut, bir dosya veya dizini kopyalamanızı sağlar. Örneğin, cp myfile.txt mybackup.txt komutu, myfile.txt dosyasını mybackup.txt adında bir dosyaya kopyalar.\nmv #  Bu komut, bir dosya veya dizini taşımanızı veya yeniden adlandırmanızı sağlar. Örneğin, mv myfile.txt myfolder komutu, myfile.txt dosyasını myfolder adındaki dizine taşır.\ntouch #  Bu komut, yeni bir dosya oluşturmanızı veya dosya zaman bilgilerini güncellemenizi sağlar. Örneğin, touch myfile.txt komutu, myfile.txt adında yeni bir dosya oluşturur veya dosyanın son değiştirilme zamanını günceller.\ncat #  Bu komut, bir dosyanın içeriğini görüntüler. Örneğin, cat myfile.txt komutu, myfile.txt adındaki dosyanın içeriğini görüntüler.\nless #  Bu komut, bir dosyanın içeriğini sayfa sayfa görüntüler. Örneğin, less myfile.txt komutu, myfile.txt adındaki dosyanın içeriğini sayfa sayfa görüntüler.\nhead #  Bu komut, bir dosyanın baş kısmını görüntüler. Örneğin, head myfile.txt komutu, myfile.txt adındaki dosyanın baş kısmını görüntüler.\ntail #  Bu komut, bir dosyanın son kısmını görüntüler. Örneğin, tail myfile.txt komut\ngrep #  Bu komut, bir metin dosyasındaki belirli metinleri aramanızı sağlar. Örneğin, grep \u0026ldquo;example\u0026rdquo; myfile.txt komutu, myfile.txt dosyasında \u0026ldquo;example\u0026rdquo; kelimesini arar.\necho #  Bu komut, bir metin veya değişken içeriğini ekrana yazdırır. Örneğin, echo \u0026ldquo;Hello, World!\u0026rdquo; komutu, \u0026ldquo;Hello, World!\u0026rdquo; metnini ekrana yazdırır.\nsudo #  Bu komut, bir komutu yönetici (root) olarak çalıştırmanızı sağlar. Örneğin, sudo apt-get install htop komutu, htop programını yüklerken yönetici izinleri gerektirir.\nchmod #  Bu komut, bir dosyanın izinlerini değiştirmenizi sağlar. Örneğin, chmod 755 myfile.sh komutu, myfile.sh adındaki betik dosyasının izinlerini değiştirir.\nchown #  Bu komut, bir dosyanın sahibini veya grup bilgisini değiştirmenizi sağlar. Örneğin, chown myuser myfile.txt komutu, myfile.txt adındaki dosyanın sahibini myuser olarak değiştirir.\ndf #  Bu komut, dosya sisteminizin disk kullanımını gösterir. Örneğin, df -h komutu, disk kullanımını insan tarafından okunabilir bir formatta görüntüler.\ntop #  Bu komut, sistemdeki işlemci kullanımını ve en yüksek CPU kullanan işlemleri görüntüler. Örneğin, top komutu, işlemci kullanımını ve en yüksek CPU kullanan işlemleri canlı olarak görüntüler.\n"},{"id":22,"href":"/linux-training/docs/101/kurulum/terminoloji/","title":"Terminoloji","section":"Kurulum","content":"  / (Kök dizin): Bu, tüm dosya sisteminin kök dizinidir ve tüm diğer dizinlerin üzerinde bulunur. Bu dizin, tüm sistem dosyalarını içerir ve tüm kullanıcıların erişebileceği her şey burada bulunur.\n  /boot: Bu dizin, işletim sisteminin başlangıç ​​dosyalarını içerir. Bu, önyükleme (boot) süreci sırasında kullanılır ve burada bulunan dosyalar, sistem açıldığında yüklenir.\n  /boot/efi: Bu dizin, EFI (Extensible Firmware Interface) uyumlu bir sistemde önyükleme dosyalarını içerir. EFI, BIOS\u0026rsquo;un yerini alan bir donanım arayüzüdür.\n  /swap: Bu, bir sistemdeki bellek yönetimi için kullanılan bir alanı temsil eder. Swap, fiziksel RAM\u0026rsquo;in bir uzantısı olarak kullanılır ve gerektiğinde kullanılır. Bu, sistem belleği (RAM) tükendiğinde kullanılır ve geçici bellek ihtiyacını karşılamak için kullanılır.\n  ext4 #  ext4 (dördüncü genişletilmiş dosya sistemi) Linux\u0026rsquo;ta en yaygın kullanılan dosya sistemidir. ext3\u0026rsquo;ün geliştirilmiş bir sürümüdür ve daha iyi performans, güvenilirlik ve ölçeklenebilirlik sağlar. ext4, büyük dosya boyutları, daha büyük disk boyutları ve daha iyi dosya sistemi bütünlüğü için tasarlanmıştır.\nXFS #  XFS, SGI tarafından geliştirilen ve daha sonra Linux\u0026rsquo;ta da kullanılmaya başlanan bir dosya sistemidir. Özellikle büyük dosya boyutları, büyük disk alanları ve yüksek performans gerektiren uygulamalar için önerilir. XFS, özellikle yüksek hızlı veri aktarımı, güvenilirlik ve yüksek bütünlük sağlama konusunda iyi bir performans sergiler.\nLVM #  LVM (Logical Volume Manager), Linux\u0026rsquo;ta kullanılan bir mantıksal disk yönetim sistemidir. LVM, birden fazla disk bölümünü tek bir sanal disk olarak gruplandırmanızı sağlar. Bu, disk bölümleri arasında daha kolay boyut değişikliği yapmanızı, birden fazla disk bölümü arasında veri taşımanızı ve disk hatalarına karşı daha fazla dayanıklılık sağlamanızı mümkün kılar.\nRAID #  (Redundant Array of Independent Disks), birden fazla sabit disk sürücüsünü tek bir mantıksal sürücü olarak birleştirir ve veri yedekliliği ve yüksek performans sağlar. Linux\u0026rsquo;ta RAID, birkaç farklı düzeyde uygulanabilir. Örneğin RAID 0, veriyi iki veya daha fazla disk sürücüsüne yazarak performansı artırırken, RAID 1, verileri birden fazla disk sürücüsünde yedekleyerek veri bütünlüğünü sağlar.\nGRUB #  (GNU Grand Unified Bootloader), Linux ve diğer işletim sistemlerini önyükleme sürecinde yüklemek için kullanılan bir önyükleme yükleyicisidir. GRUB, önyükleme işlemini kolaylaştırmak için bir dizi özellik sunar ve çeşitli dosya sistemleri ve disk bölümleme düzenleri ile uyumludur.\nGRUB, BIOS veya EFI gibi donanım arayüzleri aracılığıyla önyükleme yükleyicisi olarak çalışabilir. Sistem başlatıldığında, GRUB, önyükleme menüsünü görüntüler ve kullanıcının hangi işletim sistemini veya yüklü olan hangi Linux çekirdeğini yüklemek istediğini seçmesine izin verir. Seçim yapıldıktan sonra, GRUB, seçilen işletim sistemini veya çekirdeği belleğe yükler ve işletim sistemini başlatır.\nGRUB ayrıca çeşitli yükleme seçeneklerini de destekler, örneğin hata ayıklama modu, tek kullanıcı modu vb. GRUB, Linux sistem yöneticileri için çok önemli bir araçtır ve sistemin önyükleme sürecinde herhangi bir sorun olması durumunda, sorun giderme ve onarım işlemleri için kullanılabilir.\n"},{"id":23,"href":"/linux-training/docs/101/paket-y%C3%B6netimi/terminoloji/","title":"Terminoloji","section":"Paket Yönetimi","content":"Repository #  Bir bilgi deposunu veya bir veritabanını ifade eder. Bilgisayar bilimlerinde, bir yazılım projesi veya kaynak kodu gibi diğer dijital materyallerin saklandığı, yönetildiği ve paylaşıldığı bir depoya genellikle \u0026ldquo;repository\u0026rdquo; denir.\nBu depolama alanı, birçok kişinin aynı proje üzerinde çalışmasına olanak tanır ve bu nedenle, yazılım geliştirme ekibi, farklı sürümleri ve değişiklikleri yönetmek, düzenlemek ve takip etmek için bu depolama alanını kullanabilir.\n.deb #  Debian, Ubuntu, Mint ve tüm Debian ve Ubuntu türevleri .deb paketlerini kullanır. Bu sistemlerdeki yazılımları yönetmek için aptitude veya apt-get kullanabilirsiniz, bu araçların her ikisi de dpkg için ön uçtur.\n.rpm #  Red Hat, Fedora, CentOS, OpenSUSE, Mandriva, Red Flag ve diğerleri .rpm paketlerini kullanır. Bu sistemlerde yazılım paketlerini yönetmek için kullanılan araçlar yum ve rpm\u0026rsquo;dir.\ndependency #  Bazı paketlerin çalışması için başka paketlere ihtiyacı vardır. apt-get, aptitude ve yum gibi araçlar ihtiyacınız olan tüm bağımlılıkları kuracaktır. dpkg veya rpm kullanırken veya kaynaktan derlerken, bağımlılıkları kendiniz kurmanız gerekir.\n"},{"id":24,"href":"/linux-training/docs/102/monitoring/top/","title":"top","section":"Monitoring","content":"top #  top bir Linux ve Unix tabanlı işletim sistemlerinde kullanılan bir sistem izleme aracıdır. Bu araç, sistemdeki işlemci, bellek, disk, ağ ve diğer sistem kaynaklarının kullanımını gerçek zamanlı olarak takip eder.\ntop komutu, sistemdeki işlemci kullanımını, CPU zaman dilimlerini, işlemci kullanımını sıralar ve sistemdeki en çok CPU kaynağına sahip işlemleri ve diğer kaynakları tespit eder. Ayrıca, bu araç, sistemdeki tüm işlemleri, PID numaralarını, kullanılan bellek miktarını ve diğer ayrıntıları da gösterir.\ntop komutu, arayüzünde sürekli olarak güncellenen bir liste sağlar. Kullanıcılar, bu listede görüntülenen işlemleri PID numarasına veya bellek kullanımına göre sıralayabilirler. Ayrıca, kullanıcılar, işlemleri durdurabilir veya sonlandırabilir, CPU önceliklerini değiştirebilir ve sistem kaynaklarının kullanımı hakkında ayrıntılı istatistikler alabilirler.\nörnek bir top çıktısı;\ntop - 12:32:46 up 17:52, 2 users, load average: 0.00, 0.00, 0.00 Tasks: 143 total, 1 running, 141 sleeping, 1 stopped, 0 zombie %Cpu(s): 0.2 us, 0.2 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 1953.7 total, 1169.4 free, 237.9 used, 546.4 buff/cache MiB Swap: 1953.0 total, 1953.0 free, 0.0 used. 1554.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 578 systemd+ 20 0 15176 7168 6400 S 0.3 0.4 0:36.27 systemd-oomd 1 root 20 0 153104 26208 10300 S 0.0 1.3 0:02.20 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.01 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_par_gp 5 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 slub_flushwq 6 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 netns 8 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H-events_highpri 10 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 mm_percpu_wq 12 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tasks_kthread 13 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tasks_rude_kthread 14 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tasks_trace_kthread 15 root 20 0 0 0 0 S 0.0 0.0 0:00.03 ksoftirqd/0 16 root 20 0 0 0 0 I 0.0 0.0 0:02.65 rcu_preempt 17 root rt 0 0 0 0 S 0.0 0.0 0:00.18 migration/0 19 root 20 0 0 0 0 S 0.0 0.0 0:00.00 cpuhp/0 20 root 20 0 0 0 0 S 0.0 0.0 0:00.00 cpuhp/1 21 root rt 0 0 0 0 S 0.0 0.0 0:00.20 migration/1 22 root 20 0 0 0 0 S 0.0 0.0 0:00.03 ksoftirqd/1 24 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/1:0H-events_highpri 25 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kdevtmpfs 26 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 inet_frag_wq 27 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kauditd 29 root 20 0 0 0 0 S 0.0 0.0 0:00.00 oom_reaper Şimdi bu çıktının üst bölümündeki alanı inceleyelim;\ntop - 12:32:46 up 17:52, 2 users, load average: 0.00, 0.00, 0.00 Tasks: 143 total, 1 running, 141 sleeping, 1 stopped, 0 zombie %Cpu(s): 0.2 us, 0.2 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 1953.7 total, 1169.4 free, 237.9 used, 546.4 buff/cache MiB Swap: 1953.0 total, 1953.0 free, 0.0 used. 1554.2 avail Mem Yukarıdaki çıktıdaki alanlar ve anlamları;\n top: Komutun adı 12:32:46: Sistem saati up 17:52: Sistem çalışma süresi 2 users: Şu anda oturum açmış 2 kullanıcı var load average: 0.00, 0.00, 0.00: Son 1, 5 ve 15 dakikalık yük ortalaması Tasks: Toplam işlem sayısı 143 total: Toplam işlem sayısı 1 running: Şu anda çalışan işlem sayısı 141 sleeping: Uyuyan işlem sayısı 1 stopped: Durdurulmuş işlem sayısı 0 zombie: Zombie işlem sayısı %Cpu(s): CPU kullanım istatistikleri 0.2 us: Kullanıcı modunda kullanılan CPU yüzdesi 0.2 sy: Sistem modunda kullanılan CPU yüzdesi 0.0 ni: Öncelikli çalıştırılan işlemde kullanılan CPU yüzdesi 99.7 id: CPU\u0026rsquo;nun boşta kalma yüzdesi 0.0 wa: Bekleyen I/O işlemi yüzdesi 0.0 hi: Kesinti işlemi yüzdesi 0.0 si: Yazma işlemi yüzdesi 0.0 st: Sanal CPU yüzdesi MiB Mem: Bellek kullanım istatistikleri 1953.7 total: Toplam bellek miktarı 1169.4 free: Boş bellek miktarı 237.9 used: Kullanılan bellek miktarı 546.4 buff/cache: Tamponlanmış bellek miktarı MiB Swap: Takas kullanım istatistikleri 1953.0 total: Toplam takas miktarı 1953.0 free: Boş takas miktarı 0.0 used: Kullanılan takas miktarı 1554.2 avail Mem: Kullanılabilir bellek miktarı  PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND  PID: İşlem kimliği (Process ID) USER: İşlemi başlatan kullanıcı PR: İşlem önceliği (Priority) NI: İşlem öncelik seviyesi (Nice value) VIRT: Sanal bellek kullanımı (Virtual memory usage) RES: Gerçek bellek kullanımı (Resident set size) SHR: Paylaşılan bellek kullanımı (Shared memory usage) S: İşlem durumu (Process status) %CPU: CPU kullanım yüzdesi (CPU usage percentage) %MEM: Bellek kullanım yüzdesi (Memory usage percentage) TIME+: İşlem çalışma süresi (Process CPU time) COMMAND: İşlem adı (Command name)  İşlem önceliği, bir işlemin işletim sistemi tarafından ne kadar öncelikli olduğunu gösteren bir sayısal değerdir. Düşük bir işlem önceliği, yüksek bir öncelikli işlem tarafından kesilebilirken, yüksek bir önceliği olan bir işlem diğer düşük öncelikli işlemler tarafından kesilemez. (-20 , 19)  Kısa Yollar #   k: Belirli bir PID\u0026rsquo;ye sahip işlemi sonlandırmak için kullanılır. u: Belirli bir kullanıcının işlemlerini görmek için kullanılır. M: İşlem listesini bellek kullanımına göre sıralamak için kullanılır. P: İşlem listesini CPU kullanımına göre sıralamak için kullanılır. T: İşlem listesini çalışma süresine göre sıralamak için kullanılır. q: top komutunu sonlandırır.  "},{"id":25,"href":"/linux-training/docs/102/edit%C3%B6r/vim/","title":"vim","section":"Editör","content":"Vim, Linux ve UNIX sistemlerinde kullanılan bir metin düzenleyicisidir.\n  Metin dosyası açmak için aşağıdaki komutu kullanabilirsiniz:\n  Metin dosyası açıldıktan sonra Vim normal moduna geçer. Normal modda i tuşuna basarak insert moduna geçebilirsiniz. Insert modunda klavyeniz ile yazı yazabilirsiniz.\n  Insert modundan normal moda dönmek için ESC tuşuna basabilirsiniz.\n  Normal modda x tuşuna basarak karakterleri silerek düzenleyebilirsiniz. Örneğin, bir karakteri silmek için \u0026ldquo;x\u0026rdquo; tuşuna basabilirsiniz.\n  Normal modda \u0026ldquo;dd\u0026rdquo; tuş kombinasyonunu kullanarak satırları silebilirsiniz.\n  Normal modda \u0026ldquo;:w\u0026rdquo; komutunu kullanarak metin dosyasını kaydedebilirsiniz.\n  Normal modda \u0026ldquo;:q\u0026rdquo; komutunu kullanarak Vim editöründen çıkabilirsiniz.\n  Normal modda \u0026ldquo;:wq\u0026rdquo; komutunu kullanarak dosyayı kaydedip çıkabilirsiniz.\n  Normal modda \u0026ldquo;/\u0026rdquo; tuşuna basarak arama yapabilirsiniz. Aramak istediğiniz kelimeyi yazıp ENTER tuşuna basabilirsiniz. Sonraki eşleşmeler için \u0026ldquo;n\u0026rdquo; tuşuna basabilirsiniz.\n  Normal modda \u0026ldquo;G\u0026rdquo; tuşuna basarak dosyanın sonuna gidebilirsiniz. Aynı zamanda dosyanın belirli bir satırına gitmek için \u0026ldquo;:\u0026lt;satır numarası\u0026gt;\u0026rdquo; komutunu da kullanabilirsiniz. Örneğin, \u0026ldquo;:15\u0026rdquo; komutu ile 15. satıra gidebilirsiniz.\n  "},{"id":26,"href":"/linux-training/docs/102/script/while/","title":"while","section":"Script","content":"while döngüsü, belirli bir şart doğru olduğu sürece bir işlemi tekrar tekrar yapmak için kullanılır. Örneğin, bir dizi sayıyı toplamak isteyebilirsiniz. Aşağıdaki örnekte, 1\u0026rsquo;den 5\u0026rsquo;e kadar olan sayıları toplar:\nsum=0 i=1  while [ $i -le 5 ] do  sum=$((sum+i))  i=$((i+1)) done  echo \u0026#34;Toplam: $sum\u0026#34; Örnek #  #!/bin/bash # Bu script ile sayıları 1\u0026#39;den 10\u0026#39;a kadar yazdırıyoruz.  sayi=1 while [ $sayi -le 10 ] do  echo $sayi  sayi=$((sayi+1)) done Burada, sayi değişkenini 1\u0026rsquo;den başlatıyoruz. Döngü her çalıştığında, ekrana sayi değişkeninin değerini yazdırıyoruz ve sayi değişkenini 1 artırıyoruz. Bu şekilde döngü 10\u0026rsquo;a kadar devam ediyor.\n"},{"id":27,"href":"/linux-training/docs/102/network/fail2ban/","title":"fail2ban","section":"Network","content":"Fail2ban, sunucularda otomatik olarak güvenlik önlemleri alarak, sisteme yapılan saldırıları engellemek için kullanılan bir açık kaynaklı bir yazılımdır. Fail2ban, güvenliği artırmak için sunucu log dosyalarını izleyerek saldırıları tespit eder ve bu saldırıların ardından saldırganın IP adresini belirler ve bu IP adresini engeller.\nFail2ban, birden fazla protokolü destekleyen bir yazılımdır ve bir dizi filtreleme kuralları içerir. Örnek olarak, SSH sunucusunda başarısız oturum açma denemelerini tespit edebilir ve ardından bu IP adreslerini belirleyip firewall kurallarını kullanarak IP adreslerini engelleyebilir.\nFail2ban\u0026rsquo;ın kullanımı oldukça basittir. İlk olarak, sunucuda Fail2ban\u0026rsquo;ı yüklemek ve yapılandırmak gerekir. Daha sonra, izlenecek log dosyalarını ve hangi saldırıları tespit edeceğini belirlemek için filtre kuralları oluşturulur. Fail2ban kurallarının yapılandırılması, jail.conf dosyasında yapılır. Bu dosyada, izlenen log dosyaları, filtreleme kuralları ve ne kadar süreyle IP adreslerinin engelleneceği gibi ayarlar yapılabilmektedir.\nFail2ban\u0026rsquo;ın kurulumu ve yapılandırması çeşitli Linux dağıtımlarında farklılık gösterir, ancak genellikle aşağıdaki adımlar takip edilir:\n Sistemde gerekli bağımlılıkların yüklenmesi:  yum install fail2ban  Fail2ban\u0026rsquo;ın yapılandırılması:  vi /etc/fail2ban/jail.conf  Filtrelerin yapılandırılması:  vi /etc/fail2ban/filter.d/filtername.conf  Fail2ban\u0026rsquo;ın yeniden başlatılması:  systemctl restart fail2ban Fail2ban\u0026rsquo;ın örnek kullanımlarından biri, SSH sunucularındaki başarısız oturum açma girişimlerinin engellenmesidir. Bu saldırıları engellemek için, jail.conf dosyasında aşağıdaki ayarlar yapılabilir:\n[ssh] enabled = true port = ssh filter = sshd logpath = /var/log/auth.log maxretry = 3 findtime = 600 bantime = 1800 Bu ayarlara göre, 3 defa başarısız oturum açma girişiminde bulunan bir IP adresi 10 dakika boyunca engellenecek ve 30 dakika sonra engeli kaldırılacaktır.\nFail2ban, sunucular için önemli bir güvenlik aracıdır ve saldırılara karşı etkili bir koruma sağlayabilir.\n"},{"id":28,"href":"/linux-training/docs/101/kurulum/fedora-server/","title":"Fedora Kurulum","section":"Kurulum","content":"Fedora, bir Linux işletim sistemi dağıtımıdır. Fedora, Red Hat Enterprise Linux (RHEL) işletim sistemi ve özgür ve açık kaynak kodlu yazılımlar topluluğu olan Fedora Projesi tarafından desteklenir. Fedora, ücretsizdir ve herkes tarafından kullanılabilir.\nFedora, birçok kullanıcının özgür ve açık kaynak kodlu yazılımlarla çalışmayı tercih ettiği bir işletim sistemi olarak öne çıkar. Fedora, bir masaüstü işletim sistemi olarak kullanılabileceği gibi sunucu veya gömülü sistemler için de uygun olabilir. Fedora, sık güncellemeleri ve geniş bir yazılım deposu ile de öne çıkar.\n"},{"id":29,"href":"/linux-training/docs/102/kernel/grub/","title":"grub","section":"Kernel","content":"GRUB (Grand Unified Bootloader), bilgisayarınızı açarken hangi işletim sistemini başlatacağınızı seçmenize izin veren bir önyükleme yükleyicisidir. GRUB, Linux ve diğer işletim sistemlerinin önyükleme işlemini kolaylaştırır.\nGRUB ayarları genellikle \u0026ldquo;/etc/default/grub\u0026rdquo; dosyasında bulunur. Bu dosyada, GRUB önyükleme menüsünün görünümünü ve davranışını değiştirebileceğiniz bir dizi değişken bulunur.\nÖrneğin, \u0026ldquo;GRUB_TIMEOUT\u0026rdquo; değişkeni, önyükleme menüsünün görüntülenme süresini belirler. \u0026ldquo;GRUB_DEFAULT\u0026rdquo; değişkeni, önyükleme menüsünde varsayılan olarak seçilen işletim sistemini belirler. \u0026ldquo;GRUB_CMDLINE_LINUX\u0026rdquo; değişkeni, Linux çekirdeğinin önyükleme argümanlarını belirtir.\nGRUB ayarlarınızı değiştirmek için, \u0026ldquo;/etc/default/grub\u0026rdquo; dosyasını bir metin editörü ile açın, değişikliklerinizi yapın ve dosyayı kaydedin. Daha sonra, \u0026ldquo;sudo update-grub\u0026rdquo; komutunu kullanarak değişiklikleri uygulayabilirsiniz. Bu komut, GRUB konfigürasyon dosyasını yeniden oluşturacak ve değişikliklerinizi etkinleştirecektir.\n[root@localhost ~]# cat /etc/default/grub GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=\u0026#34;$(sed \u0026#39;s, release .*$,,g\u0026#39; /etc/system-release)\u0026#34; GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT=\u0026#34;console\u0026#34; GRUB_CMDLINE_LINUX=\u0026#34;rhgb quiet\u0026#34; GRUB_DISABLE_RECOVERY=\u0026#34;true\u0026#34; GRUB_ENABLE_BLSCFG=true   GRUB_TIMEOUT=5: Bu, GRUB menüsünün görüntülenme süresini 5 saniyeye ayarlar. Bu süre sonunda, varsayılan işletim sistemi otomatik olarak başlatılır.\n  GRUB_DISTRIBUTOR=\u0026quot;$(sed \u0026rsquo;s, release .*$,,g\u0026rsquo; /etc/system-release)\u0026quot;: Bu satır, GRUB menüsünde gösterilecek dağıtım adını ayarlar. Bu satır örnek olarak CentOS/RHEL işletim sistemlerinde kullanılabilir.\n  GRUB_DEFAULT=saved: Bu, son seçilen işletim sistemini varsayılan olarak ayarlar. Bu özelliği kullanarak, her seferinde manuel olarak seçmeniz gerekmez.\n  GRUB_DISABLE_SUBMENU=true: Bu, alt menülerin kullanılmasını devre dışı bırakır. Bu özellik sayesinde, GRUB menüsü daha basit ve kullanıcı dostu hale getirilir.\n  GRUB_TERMINAL_OUTPUT=\u0026ldquo;console\u0026rdquo;: Bu, GRUB\u0026rsquo;un terminale çıktı göndermesini ayarlar.\n  GRUB_CMDLINE_LINUX=\u0026ldquo;rhgb quiet\u0026rdquo;: Bu, Linux çekirdeği için komut satırı parametrelerini belirler. rhgb ve quiet parametreleri, önyükleme işlemi sırasında çıktıyı minimumda tutar ve daha iyi bir kullanıcı deneyimi sağlar.\n  GRUB_DISABLE_RECOVERY=\u0026ldquo;true\u0026rdquo;: Bu, kurtarma modunu devre dışı bırakır.\n  GRUB_ENABLE_BLSCFG=true: Bu, BootLoaderSpecification (BLS) yapılandırmasını etkinleştirir. Bu özellik, işletim sistemi güncelleştirmeleri sırasında GRUB yapılandırmasını daha kolay hale getirir.\n  Bir modülü disable etmek #  Bir kernel modülünü GRUB\u0026rsquo;da devre dışı bırakmak için, GRUB_CMDLINE_LINUX satırına modprobe.blacklist=modul_adı parametresini eklemeniz gerekiyor. Burada, modul_adı kısmını devre dışı bırakmak istediğiniz kernel modülünün adı ile değiştirmelisiniz.\nÖrneğin, eğer pcspkr kernel modülünü devre dışı bırakmak isterseniz, /etc/default/grub dosyasındaki GRUB_CMDLINE_LINUX satırını aşağıdaki gibi değiştirebilirsiniz:\nGRUB_CMDLINE_LINUX=\u0026#34;rhgb quiet modprobe.blacklist=pcspkr\u0026#34; Yapılan değişiklikleri kaydettikten sonra, sudo update-grub komutuyla GRUB yapılandırmasını güncellemeniz gerekiyor.\npcspkr modülü, Linux çekirdeği tarafından yüklenen bir kernel modülüdür. Bu modül, sistemin hoparlöründen çıkan tiz ve kısa bip seslerini üretmek için kullanılır.  GRUB ayarları ile yapabileceğiniz bazı şeyler şunlardır:\n Başlangıç ​​bekleme süresini ayarlama veya değiştirme Önyükleme sırasında kullanılacak varsayılan işletim sistemi veya çekirdek sürümünü belirleme Kernel parametrelerini belirleme veya düzenleme Kernel modüllerini yükleme veya kaldırma Sistem hatalarının veya diğer mesajların konsolda görüntülenip görüntülenmeyeceğini ayarlama Başlatma işleminin başarısız olması durumunda, sistem kurtarma modunda açılabilir Başlangıçta farklı bir dil ve klavye düzeni seçebilme  "},{"id":30,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/ip/","title":"IP","section":"Ağ Yönetimi","content":"İki farklı IP adresi türü mevcuttur: IPv4 (sürüm 4) ve IPv6 (sürüm 6). IPv4 daha eskidir ve çok daha yaygın olarak kullanılırken, IPv6 daha yenidir ve eski standardın doğasında bulunan sınırlamaları aşmak ve daha birçok olası adres sağlamak için tasarlanmıştır.\nIPv4, adresler için 32 bit kullanır; yalnızca 4,3 milyar benzersiz adres mevcuttur. Ayrıca, birçok adres tahsis edilir ve rezerve edilir, ancak gerçekte kullanılmaz. IPv4\u0026rsquo;ün gelecekteki ihtiyaçları karşılamak için yetersiz olduğu düşünülüyor çünkü küresel ağda bulunan cihazların sayısı son yıllarda çok arttı.\nIPv6, adresler için 128 bit kullanır; bu, 3,4 X 1038 benzersiz adrese izin verir. Daha geniş bir bilgisayar ağınız varsa ve daha fazlasını eklemek istiyorsanız, daha benzersiz adresler sağladığı için IPv6\u0026rsquo;ya geçmek isteyebilirsiniz. Ancak, IPv6\u0026rsquo;ya geçmek karmaşık olabilir; iki protokol her zaman birlikte iyi çalışmaz. Bu nedenle, ekipmanı ve adresleri IPv6\u0026rsquo;ya taşımak önemli bir çaba gerektirir ve başlangıçta amaçlandığı kadar hızlı olmamıştır.\n[ergunbilsel@localhost linux-101]$ nslookup lwn.net Server:\t127.0.0.53 Address:\t127.0.0.53#53  Non-authoritative answer: Name:\tlwn.net Address: 173.255.236.65 Name:\tlwn.net Address: 2600:3c03::f03c:93ff:febd:80f5 nslookup, alan adı sistemi (DNS) üzerinden bir alan adının veya IP adresinin çözülmesi için kullanılan bir komut satırı aracıdır. Windows, macOS ve Linux gibi birçok işletim sisteminde bulunur.  IPv4\u0026rsquo;ün ortadan kalkmamasının bir nedeni, NAT (Ağ Adresi Çevirisi) gibi yöntemlerle çok daha fazla adresi etkili bir şekilde kullanılabilir hale getirmenin yaygın olarak kullanılan yollarının olmasıdır. NAT, her biri yalnızca yerel ağda görülen benzersiz bir adrese sahip, yerel olarak bağlı birçok bilgisayar arasında bir IP adresinin paylaşılmasını sağlar. Bu, kurumsal ortamlarda kullanılırken, basit ev ağlarında da kullanılır. Örneğin, İnternet Sağlayıcınıza bağlı bir yönlendiriciniz varsa (kablolu sistem gibi), size harici olarak görünür bir adres verir, ancak evinizdeki her cihaza, dış dünya tarafından görülemeyen, ayrı bir yerel adres verir.\n"},{"id":31,"href":"/linux-training/docs/102/network/iptables/","title":"iptables","section":"Network","content":"iptables, Linux işletim sistemi için geliştirilmiş bir güvenlik yazılımıdır. Paket filtreleme, ağ adresi çevirme (NAT) ve port yönlendirme gibi işlevleri yerine getirir. İptables, Linux\u0026rsquo;un dahili bir parçasıdır ve çoğu Linux dağıtımında mevcuttur. Ayrıca, birçok güvenlik duvarı uygulaması da iptables tabanlıdır.\nİptables, bir dizi kurala dayalı olarak çalışır. Her bir kural, bir paketin belirli bir eylem için uygun olup olmadığını belirler. Paketler, gelen ve giden trafiği kontrol etmek için farklı zincirlerde işlenir. Bu zincirler, paketin kaynağına ve hedefine göre belirlenir.\nÖrnek olarak, bir web sunucusu üzerindeki bir iptables kuralları, sadece belirli IP adreslerinden gelen HTTP trafiğini kabul etmek ve diğer tüm trafiği reddetmek için ayarlanabilir. Bu şekilde, saldırganların sunucuya erişmelerini engelleyebilirsiniz.\nİptables kurallarının listelenmesi:\niptables -L Bu komut, mevcut tüm iptables kurallarını listeler.\nİptables kuralı ekleme:\niptables -A INPUT -s 192.168.0.0/24 -j DROP Bu komut, gelen bağlantılarda kaynak IP\u0026rsquo;si 192.168.0.0/24 olanları engeller.\nİptables kuralı silme:\niptables -D INPUT -s 192.168.0.0/24 -j DROP Belirli bir IP adresinden gelen trafiği kabul etme:\niptables -A INPUT -s 192.168.1.100 -j ACCEPT  Belirli bir portu engelleme:  8080 numaralı HTTP portunu engellemek istiyoruz. Bu durumda aşağıdaki iptables komutunu kullanabiliriz:\niptables -A INPUT -p tcp --dport 8080 -j DROP Bu komut, gelen tüm TCP trafiğini 8080 portundan düşürecek (DROP).\nYukarıdaki örneler gelen trafikler içindir.\nIptables ile giden trafiği engellemek için OUTPUT chain\u0026rsquo;inin kullanılması gerekmektedir. OUTPUT chain\u0026rsquo;i, paketin sunucudan ayrılıp gitmek üzere dışarı çıkacağı zamanda kontrol edilir. Giden trafiği engellemek için OUTPUT chain\u0026rsquo;indeki DROP hedefi kullanılabilir.\nAşağıdaki örnekte, tüm çıkış trafiği engellenir:\niptables -A OUTPUT -j DROP Bu komut, tüm çıkış trafiğini engelleyerek sunucunun internete erişimini de engelleyecektir. Bu nedenle, sadece belirli portlara izin vermek için filtreleme kuralları eklenmelidir. Örneğin, yalnızca HTTP (port 80) trafiğine izin vermek için aşağıdaki komut kullanılabilir:\niptables -A OUTPUT -p tcp --dport 80 -j ACCEPT iptables -A OUTPUT -j DROP Bu komutlar, HTTP trafiğine izin vermek için bir kural ekler ve diğer tüm çıkış trafiğini engeller.\n"},{"id":32,"href":"/linux-training/docs/101/kullan%C4%B1c%C4%B1-ve-yetkilendirme/kullan%C4%B1c%C4%B1-silme/","title":"Kullanıcı Silme","section":"Kullanıcı Ve Yetkilendirme","content":"Kullanıcı Silme #  Linux\u0026rsquo;ta bir kullanıcı hesabını silmek için kullanılır. Bu komut, kullanıcının home dizinini ve mail kutusunu da siler.\nuserdel new_user Ayrıca, userdel komutunu kullanarak kullanıcının home dizinini silmeden, sadece kullanıcı hesabını kaldırmak için -r seçeneğini kullanabilirsiniz:\nuserdel -r new_user Kaldırmak istediğiniz kullanıcı hala oturum açmışsa veya bu kullanıcıya ait çalışan işlemler varsa userdel komutu kullanıcının kaldırılmasına izin vermez.\nBu durumda, kullanıcının oturumunu kapatması ve kullanıcının çalışan tüm işlemlerini şu komutla sonlandırması önerilir killall :\nkillall -u new_user "},{"id":33,"href":"/linux-training/docs/101/linux/tarihcesi/","title":"Linux Tarihçesi","section":"Linux","content":"Linux, ilk olarak 1991 yılında Linus Torvalds tarafından geliştirildi. Torvalds, Helsinki Üniversitesi\u0026rsquo;nde bilgisayar bilimleri öğrencisiydi ve MINIX adlı bir işletim sistemi üzerinde çalışıyordu. Ancak MINIX\u0026rsquo;in sınırlamaları onu kısıtladığı için kendi işletim sistemini geliştirmeye karar verdi. Linux, açık kaynaklı bir işletim sistemi olarak geliştirildi ve tüm kaynak kodu kamuya açıktır. Bu, diğer yazılım geliştiricilerinin kodu geliştirmesine, değiştirmesine ve paylaşmasına olanak tanır. Bu nedenle, Linux birçok farklı işletim sistemi dağıtımı ile birlikte gelir, bu da kullanıcıların işletim sistemi için farklı özellikler ve uygulamalar seçmesine olanak tanır. Linux, özellikle sunucu işletim sistemleri ve bilgisayar ağları için yaygın olarak kullanılmaktadır. Bununla birlikte, masaüstü kullanıcıları için de birçok Linux dağıtımı mevcuttur ve açık kaynaklı doğası sayesinde, kullanıcılar işletim sistemindeki tüm detayları özelleştirebilirler.\n"},{"id":34,"href":"/linux-training/docs/102/konteyner/lxc/","title":"lxc","section":"Konteyner","content":"LXC (Linux Containers) bir konteynerleştirme teknolojisidir. LXC, Linux çekirdeği için bir sanallaştırma aracıdır ve birden fazla izole edilmiş Linux çevresi (container) çalıştırmaya olanak sağlar. Konteyner teknolojisi, her bir container\u0026rsquo;ın bağımsız çalışabilen bir işletim sistemi ve uygulama yığınına sahip olduğu bir yöntemdir.\nLXC, her bir container\u0026rsquo;ın host işletim sistemi üzerinde bir izolasyon katmanı sağlar. Bu izolasyon katmanı, container\u0026rsquo;ın bağımsız bir dosya sistemi, ağ arabirimi, kullanıcıları ve bağlı uygulamaları içerdiği anlamına gelir. LXC, container\u0026rsquo;ların kaynaklarını (CPU, bellek, disk alanı vb.) doğrudan host işletim sisteminden alır ve böylece sanal makinelere göre daha hafif bir yapıdadır.\nLXC, container\u0026rsquo;ların yönetimini kolaylaştırmak için bir dizi araç sunar. Bu araçlar, container\u0026rsquo;ları başlatma, durdurma, oluşturma, silme ve yönetme işlemlerini yapmak için kullanılabilir. LXC ayrıca, farklı container\u0026rsquo;ların birbirleriyle nasıl iletişim kuracağına dair ayarları da yapmak için bir dizi ağ aracı sunar.\nLXC\u0026rsquo;nin avantajları arasında yüksek performans, düşük kaynak tüketimi ve esneklik yer alır. LXC, sanal makinelerle karşılaştırıldığında daha hızlı bir başlatma süresine sahiptir ve daha hafiftir. Bununla birlikte, LXC container\u0026rsquo;ları tamamen izole edemez ve sınırlı bir güvenlik seviyesi sağlar.\nYükleme #  İlk olarak, sistemde LXC kurulu değilse, paket yöneticisi aracılığıyla LXC paketlerini yüklemeniz gerekiyor.\nyum install lxc lxc-templates Konteyner Oluşturma #  LXC yüklendikten sonra, bir LXC konteyneri oluşturabilirsiniz. Aşağıdaki komutu kullanarak yeni bir konteyner oluşturabilirsiniz:\nlxc-create -t download -n infosec -- -d fedora -r 38 -a amd64 Başlatma #  Konteyneri başlatmak için aşağıdaki komutu kullanabilirsiniz:\nlxc-start -n infosec Bağlanma #  Konteynerinize bağlanmak için aşağıdaki komutu kullanabilirsiniz:\nlxc exec infosec -- /bin/bash Durdurma #  lxc-stop -n infosec Silme #  lxc-destroy -n infosec "},{"id":35,"href":"/linux-training/docs/101/sorun-giderme/secure/","title":"secure","section":"Sorun Giderme","content":"Linux sistemlerinde, /var/log/secure dosyası, sistem güvenliğiyle ilgili bilgilerin kaydedildiği bir günlük dosyasıdır. Bu dosyaya genellikle şunlar kaydedilir:\n Yetkilendirme işlemleri (login, logout, başarısız login denemeleri) Süper kullanıcı (root) işlemleri SSH oturum açma girişimleri PAM (Pluggable Authentication Modules) etkinlikleri Sudo komutu kullanımı Güvenlik duvarı etkinlikleri Bu dosya, sistem yöneticilerinin sistem güvenliğini izlemesine ve sorunları tespit etmelerine yardımcı olur.  Örnek bir çıktı;\n[root@localhost mnt]# tail -f /var/log/secure May 7 17:34:14 localhost sudo[142319]: ergunbilsel : TTY=pts/4 ; PWD=/home/ergunbilsel ; USER=root ; COMMAND=/usr/bin/dmesg -n 7 May 7 17:34:14 localhost sudo[142319]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000) May 7 17:34:14 localhost sudo[142319]: pam_unix(sudo:session): session closed for user root May 7 17:35:52 localhost sudo[142553]: ergunbilsel : TTY=pts/4 ; PWD=/opt ; USER=root ; COMMAND=/usr/bin/dd if=/dev/zero of=test.img bs=1M count=1024 May 7 17:35:52 localhost sudo[142553]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000) May 7 17:35:55 localhost sudo[142553]: pam_unix(sudo:session): session closed for user root May 7 17:36:13 localhost sudo[142600]: ergunbilsel : TTY=pts/4 ; PWD=/opt ; USER=root ; COMMAND=/usr/bin/dd if=/dev/zero of=test.img bs=1M count=1024 May 7 17:36:13 localhost sudo[142600]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000) May 7 17:36:59 localhost sudo[142600]: pam_unix(sudo:session): session closed for user root May 7 17:37:13 localhost su[142774]: pam_unix(su:session): session opened for user root(uid=0) by (uid=1000) "},{"id":36,"href":"/linux-training/docs/102/systemd/systemd/","title":"servis ekleme","section":"Systemd","content":"systemd, bir Linux sistem yönetimi sistemidir. Sistemin açılış, kapanış ve hizmet yönetimi işlemlerini yönetir. Aynı zamanda, sistem loglarını yönetir, süreçleri yönetir ve sistem zamanlamasını sağlar.\nSystemd, BSD init sistemine alternatif olarak geliştirilmiştir ve modern Linux dağıtımlarında varsayılan olarak kullanılır. Sistem yönetimi için daha yüksek seviyeli bir arayüz sağlar ve hizmetlerin birbirine bağımlılıklarını ve önceliklerini yönetebilir.\nÖrnek olarak, systemd üzerinden bir hizmetin durumunu kontrol edebilir, başlatıp durdurabilir, hizmet konfigürasyonunu değiştirebilirsiniz. Sistem başlatılırken çalıştırılacak hizmetleri belirlemek de mümkündür.\nBir önek oluşturalım. Yazmış olduğumuz bir scripti servis haline getirelim:\nİlk olarak, systemd servis dosyası oluşturmalısınız. Bunu yapmak için, /etc/systemd/system dizininde .service isimli bir dosya oluşturun ve aşağıdaki gibi içeriğini girin:\n[Unit] Description=\u0026lt;servis-ismi\u0026gt;  [Service] Type=simple ExecStart=/bin/bash /path/to/script.sh  [Install] WantedBy=multi-user.target Eklemiş olduğumuz sistemin okuması için;\nsystemctl daemon-reload Daha sonra servisi etkinleştirin ve başlatmak için:\nsystemctl enable \u0026lt;servis-ismi\u0026gt;.service systemctl start \u0026lt;servis-ismi\u0026gt;.service Servisin çalışıp çalışmadığını kontrol etmek için aşağıdaki komutu kullanabilirsiniz:\nsystemctl status \u0026lt;servis-ismi\u0026gt;.service "},{"id":37,"href":"/linux-training/docs/security/sudo/","title":"sudo","section":"Security","content":"sudo #  sudo Linux sistemlerinde güvenli bir şekilde kullanıcıların kök veya başka bir kullanıcının yetkisine sahip olmalarına izin veren bir programdır. Genellikle sistem yöneticileri tarafından kullanılır.\nsudo komutu, sistemde belirtilen kullanıcının yetkilerini geçici olarak yükseltmek için kullanılır. Bu sayede kullanıcı kök yetkilerine sahip olmadan belirli işlemleri yapabilir. Bu işlem, kök kullanıcısı olarak giriş yapmak yerine belirli bir kullanıcının belirli bir işlemi yapmasına izin verir ve güvenliği artırır.\nsudoers #  sudoers dosyası, sudo komutunun hangi kullanıcıların hangi işlemleri yapabileceğini belirlemesine yardımcı olan yapılandırma dosyasıdır. sudoers dosyası, yalnızca sistem yöneticileri tarafından değiştirilebilir.\nsudoers dosyasındaki ayarlamalar sayesinde, belirli bir kullanıcının yalnızca belirli bir komutu çalıştırmasına izin verilebilir. Böylece kullanıcıların yetkileri ihtiyaç duydukları kadarıyla yükseltilir ve gereksiz riskler azaltılmış olur.\ntest ALL=(ALL) NOPASSWD: ALL Yukarıdaki örnekte, test adlı kullanıcıya, tüm komutları çalıştırabilmesi için sudo yetkisi veriyoruz. NOPASSWD seçeneği ise, kullanıcının sudo için herhangi bir şifre girmesine gerek olmadığını belirtir.\nsudoers dosyasında değişiklik yapmak için visudo komutundan yararlanabilirsiniz. Sudoers lokasyonu /etc/sudoers  !visiblepw #  *Defaults !visiblepw satırı sudoers dosyasındaki bir parametredir ve sudo programının belirli bir davranışını değiştirir. Bu parametre etkinleştirildiğinde, kullanıcılara yönetici şifresi veya parolası sırasında geri bildirim verilmez. Yani, şifre veya parola girildiğinde ekranda karakterlerin görünür olması engellenir. Bu, güvenlik nedenleriyle kullanışlı bir özelliktir çünkü parolaların başkaları tarafından görüntülenmesini engeller.\n"},{"id":38,"href":"/linux-training/docs/102/network/tcpdump/","title":"tcpdump","section":"Network","content":"tcpdump, Linux ve Unix benzeri işletim sistemlerinde ağ trafiğini yakalamak ve analiz etmek için kullanılan bir komut satırı aracıdır. tcpdump, ağ trafiğini yakalamak için promiscuous modda çalışır ve birçok protokolü destekler.\nTcpdump, ağ trafiğini kaydetmek için kullanılabilir ve kaydedilen veriler Wireshark gibi grafik arayüzüne sahip bir araçta analiz edilebilir.\nTcpdump ayrıca, ağda meydana gelen sorunları tespit etmek için kullanılan bir araçtır. Örneğin, ağ trafiğinde neden gecikmeler veya düşük performans yaşandığını belirlemek için kullanılabilir. Ayrıca, ağda herhangi bir kötü niyetli faaliyet tespit etmek için de kullanılabilir.\nTcpdump kullanımı oldukça esnektir ve birçok farklı parametre ile çalışabilir. Bazı temel parametreler şunlardır:\n-i: Hangi arayüzün dinlenileceğini belirtir. -n: IP adreslerinin ve port numaralarının sayısal olarak görüntülenmesini sağlar. -v: Daha ayrıntılı çıktı verir. -c: Belirli bir sayıda paket yakalamak için kullanılır. Örneğin, \u0026ldquo;\u0026ldquo;\u0026ldquo;tcpdump -i enp1s0 -n -c 10\u0026quot;\u0026rdquo;\u0026rdquo; komutu, \u0026ldquo;enp1s0 \u0026quot; arayüzünden gelen ilk 10 paketi sayısal IP adresleri ve port numaralarıyla birlikte gösterecektir.\n[root@localhost /]# tcpdump -i enp1s0 -n -c 10 dropped privs to tcpdump tcpdump: verbose output suppressed, use -v[v]... for full protocol decode listening on enp1s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes 20:26:54.652683 IP 192.168.122.151.ssh \u0026gt; 192.168.122.1.46026: Flags [P.], seq 2372240427:2372240655, ack 1256259480, win 501, options [nop,nop,TS val 3001248506 ecr 2100104801], length 228 20:26:54.652908 IP 192.168.122.1.46026 \u0026gt; 192.168.122.151.ssh: Flags [.], ack 228, win 6862, options [nop,nop,TS val 2100104937 ecr 3001248506], length 0 20:26:54.744891 IP 192.168.122.151.ssh \u0026gt; 192.168.122.1.46026: Flags [P.], seq 228:616, ack 1, win 501, options [nop,nop,TS val 3001248598 ecr 2100104937], length 388 20:26:54.745050 IP 192.168.122.1.46026 \u0026gt; 192.168.122.151.ssh: Flags [.], ack 616, win 6861, options [nop,nop,TS val 2100105029 ecr 3001248598], length 0 20:26:54.845699 IP 192.168.122.151.ssh \u0026gt; 192.168.122.1.46026: Flags [P.], seq 616:972, ack 1, win 501, options [nop,nop,TS val 3001248699 ecr 2100105029], length 356 20:26:54.846005 IP 192.168.122.1.46026 \u0026gt; 192.168.122.151.ssh: Flags [.], ack 972, win 6862, options [nop,nop,TS val 2100105130 ecr 3001248699], length 0 20:26:54.949595 IP 192.168.122.151.ssh \u0026gt; 192.168.122.1.46026: Flags [P.], seq 972:1328, ack 1, win 501, options [nop,nop,TS val 3001248803 ecr 2100105130], length 356 20:26:54.949890 IP 192.168.122.1.46026 \u0026gt; 192.168.122.151.ssh: Flags [.], ack 1328, win 6862, options [nop,nop,TS val 2100105234 ecr 3001248803], length 0 20:26:55.053679 IP 192.168.122.151.ssh \u0026gt; 192.168.122.1.46026: Flags [P.], seq 1328:1700, ack 1, win 501, options [nop,nop,TS val 3001248907 ecr 2100105234], length 372 20:26:55.053931 IP 192.168.122.1.46026 \u0026gt; 192.168.122.151.ssh: Flags [.], ack 1700, win 6861, options [nop,nop,TS val 2100105338 ecr 3001248907], length 0 Tcpdump ayrıca, belirli bir protokolü dinlemek veya belirli bir IP adresi veya port numarasına sahip trafiği dinlemek için de kullanılabilir. Örneğin, sudo tcpdump tcp port 22 komutu, TCP protokolünün 22 numaralı bağlantı noktasında oluşan trafiği gösterecektir.\n[root@localhost /]# tcpdump tcp port 22 dropped privs to tcpdump tcpdump: verbose output suppressed, use -v[v]... for full protocol decode listening on enp1s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes 20:35:03.119036 IP _gateway.46026 \u0026gt; localhost.localdomain.ssh: Flags [.], ack 2372301851, win 6862, options [nop,nop,TS val 2100593401 ecr 3001736972], length 0 20:35:03.119154 IP localhost.localdomain.ssh \u0026gt; _gateway.46026: Flags [P.], seq 1:197, ack 0, win 501, options [nop,nop,TS val 3001736972 ecr 2100593401], length 196 20:35:03.119343 IP _gateway.46026 \u0026gt; localhost.localdomain.ssh: Flags [.], ack 197, win 6862, options [nop,nop,TS val 2100593401 ecr 3001736972], length 0 20:35:03.198448 IP localhost.localdomain.ssh \u0026gt; _gateway.46026: Flags [P.], seq 197:569, ack 0, win 501, options [nop,nop,TS val 3001737052 ecr 2100593401], length 372 20:35:03.198671 IP localhost.localdomain.ssh \u0026gt; _gateway.46026: Flags [P.], seq 569:765, ack 0, win 501, options [nop,nop,TS val 3001737052 ecr 2100593401], length 196 20:35:03.198688 IP _gateway.46026 \u0026gt; localhost.localdomain.ssh: Flags [.], ack 569, win 6861, options [nop,nop,TS val 2100593481 ecr 3001737052], length 0 20:35:03.198745 IP _gateway.46026 \u0026gt; localhost.localdomain.ssh: Flags [.], ack 765, win 6862, options [nop,nop,TS val 2100593481 ecr 3001737052], length 0 "},{"id":39,"href":"/linux-training/docs/security/who/","title":"who","section":"Security","content":"who komutu, Linux ve Unix sistemlerinde mevcut kullanıcıların listesini gösteren bir komuttur. Ayrıca hangi terminal üzerinde oturum açtığınızı ve ne kadar süreyle oturum açık kaldığınızı da gösterir.\nwho komutunun bazı yaygın seçenekleri şunlardır:\n-a: Tüm girişleri (normal, sistem ve son oturum) gösterir.\n[root@localhost ~]# who -a  system boot 2023-05-09 09:10  run-level 3 2023-05-09 09:10 root + tty1 2023-05-09 09:13 04:49 710 root + pts/0 2023-05-09 09:29 . 1386 (192.168.122.1) test + pts/1 2023-05-09 14:10 00:01 2020 (192.168.122.1) -b: Sistemin son yeniden başlatılma zamanını gösterir.\n[root@localhost ~]# who -b  system boot 2023-05-09 09:10 -H: Başlık satırı olmadan çıktıyı gösterir.\n[root@localhost ~]# who -H NAME LINE TIME COMMENT root tty1 2023-05-09 09:13 root pts/0 2023-05-09 09:29 (192.168.122.1) test pts/1 2023-05-09 14:10 (192.168.122.1) -q: Giriş yapan kullanıcıların sayısını gösterir.\n[root@localhost ~]# who -q root root test # users=3 -s: Yalnızca normal oturumları gösterir.\n[root@localhost ~]# who -s root tty1 2023-05-09 09:13 root pts/0 2023-05-09 09:29 (192.168.122.1) test pts/1 2023-05-09 14:10 (192.168.122.1) "},{"id":40,"href":"/linux-training/docs/102/konteyner/docker/","title":"docker","section":"Konteyner","content":"Docker, uygulamaların bir yazılım paketi olarak paketlenmesi, taşınması ve çalıştırılması için açık kaynaklı bir konteyner teknolojisidir. Docker, uygulamaların ve bağımlılıklarının sanal ortamlarda (konteynerler) çalıştırılmasını sağlar, bu sayede uygulamaların daha hızlı, güvenilir ve taşınabilir olmasını sağlar. Docker konteyner teknolojisi, farklı işletim sistemleri ve altyapılar üzerinde de çalışabilir.\nDocker kullanarak bir uygulama çalıştırmak için öncelikle Docker Engine yazılımının kurulması gerekiyor. Daha sonra, uygulamanın Dockerfile adı verilen bir dosyada tanımlanması ve Docker build komutu kullanılarak bir Docker imajının oluşturulması gerekiyor. Bu imaj, uygulamanın ve bağımlılıklarının tam bir kopyasını içerir. Bu imaj, Docker Hub gibi bir imaj deposuna yüklenerek başkaları tarafından kullanılabilir hale getirilebilir.\nBir Docker imajı çalıştırmak için Docker run komutu kullanılır. Bu komut, bir Docker konteyneri oluşturur ve imajdaki uygulamanın bu konteynerde çalışmasını sağlar. Docker konteynerleri, izole edilmiş bir çevrede çalıştığı için birden çok konteyner aynı anda aynı makinede çalıştırılabilir.\nDocker, uygulamaları hızlı bir şekilde dağıtmak ve güncellemek için de kullanılabilir. Docker Hub gibi bir imaj deposuna yüklenen imajlar, birden çok sunucuda hızlı bir şekilde çalıştırılabilir. Bu sayede, uygulamaların hızlı bir şekilde dağıtılması ve güncellenmesi mümkün hale gelir.\nÖzetle, Docker konteyner teknolojisi, uygulamaların izole edilmiş sanal ortamlarda çalıştırılmasını sağlayan açık kaynaklı bir teknolojidir.\nKurulum #  yum install docker-ce docker-ce-cli containerd.io Başlatma #  Docker servisini başlatmak için aşağıdaki komutu çalıştırın:\nsystemctl start docker Konteyner Kaldırma #  İlk konteyneri çalıştırmak için, örneğin Nginx web sunucusunu çalıştırmak için aşağıdaki komutu kullanabilirsiniz:\ndocker run -d -p 8080:80 nginx Bu komut, Nginx konteyner imajını indirir ve 8080 portundan gelen trafiği konteyner içindeki 80 numaralı porta yönlendirir.\nKonteynerin çalışıp çalışmadığını görmek için aşağıdaki komutu çalıştırabilirsiniz:\ndocker ps Durdurma #  Konteyneri durdurmak için aşağıdaki komutu kullanabilirsiniz:\ndocker stop \u0026lt;CONTAINER_ID\u0026gt; Silme #  Konteyneri silmek için aşağıdaki komutu kullanabilirsiniz:\ndocker rm \u0026lt;CONTAINER_ID\u0026gt; "},{"id":41,"href":"/linux-training/docs/101/kullan%C4%B1c%C4%B1-ve-yetkilendirme/kullan%C4%B1c%C4%B1-%C3%B6zellikleri-de%C4%9Fi%C5%9Ftirme/","title":"Kullanıcı Özelliklerini Değiştirme","section":"Kullanıcı Ve Yetkilendirme","content":"usermod #  Linux\u0026rsquo;ta bir kullanıcının özelliklerini değiştirmek için kullanılır. Bu komut, bir kullanıcının adını, ev dizinini, parolasını, grup üyeliğini vb. değiştirmek için kullanılabilir.\nUID Değiştirme\n[root@026ddc54726b /]# id new_user uid=1000(new_user) gid=1000(new_user) groups=1000(new_user) [root@026ddc54726b /]# usermod -u 1005 new_user [root@026ddc54726b /]# id new_user uid=1005(new_user) gid=1000(new_user) groups=1000(new_user) GID Değiştirme\n[root@026ddc54726b /]# id new_user uid=1005(new_user) gid=1000(new_user) groups=1000(new_user) [root@026ddc54726b /]# usermod -g 1003 new_user [root@026ddc54726b /]# id new_user uid=1005(new_user) gid=1003(new_user2) groups=1003(new_user2) User Name Değiştirme\n[root@026ddc54726b /]# usermod -l new_name_user new_user [root@026ddc54726b /]# id new_name_user uid=1005(new_name_user) gid=1003(new_user2) groups=1003(new_user2) "},{"id":42,"href":"/linux-training/docs/security/pam/","title":"pam","section":"Security","content":"PAM (Pluggable Authentication Modules), Linux sistemlerinde kullanıcı kimlik doğrulama mekanizmalarını yönetmek için kullanılan bir çerçevedir. Bu mekanizmalar, örneğin şifre denetimleri, hesap kilitleme, oturum açma sırasında iki faktörlü kimlik doğrulama gibi işlemleri gerçekleştirebilir.\nPAM, bir dizi modül kullanarak kimlik doğrulama işlemlerini yapılandırır. Her modül belirli bir görevi yerine getirir. Örneğin, bir modül kullanıcının şifresini kontrol ederken, diğer modüller hesap kilitleme ve oturum açma sırasında ek güvenlik önlemleri gibi işlemleri yapar.\nPAM, sistem yöneticilerine esnek bir yapı sağlar. Kimlik doğrulama mekanizmalarının yapılandırılması, sistem yöneticilerinin ihtiyaçlarına göre değiştirilebilir. PAM, geniş bir yelpazede kimlik doğrulama yöntemlerini destekler ve birçok uygulama tarafından kullanılır.\nPAM, çeşitli Linux dağıtımlarında standart bir bileşen haline gelmiştir ve birçok sistem yöneticisi tarafından kullanılmaktadır.\nAşamalar #  PAM modülleri, üç ayrı aşamada çalışır:\n Kimlik Doğrulama PAM, kullanıcının kimliğini doğrulamak için modülleri sırayla çalıştırır. PAM modülleri, kullanıcı adı ve parolasının yanı sıra, diğer kimlik doğrulama yöntemleri için gerekli tüm bilgileri alır ve doğrulama işlemi tamamlanana kadar devam eder.\n  Hesap Yönetimi PAM, doğrulama aşamasından sonra hesap yönetimi adımlarını yönetir. Bu adımlar, kullanıcının hesabının geçerliliğini kontrol etmek, kısıtlamaları ayarlamak ve diğer işlemleri gerçekleştirmek için kullanılır.\n  Oturum Yönetimi Son olarak, PAM oturum yönetimini sağlar. Bu aşama, kullanıcı oturumunu başlatmak veya sonlandırmak için gereken işlemleri yönetir.\n Örnek bir pam çıktısı\n[test@localhost ~]$ cat /etc/pam.d/crond # # The PAM configuration file for the cron daemon # # # Although no PAM authentication is called, auth modules # are used for credential setting auth include system-auth account required pam_access.so account include system-auth session required pam_loginuid.so session include system-auth   Auth modülleri: Kullanıcının kimliğini doğrulamak için kullanılır. Kullanıcının kimlik doğrulama bilgileri (kullanıcı adı ve parola) girildiğinde, auth modülleri bu bilgileri doğrulamak ve kullanıcının sisteme erişmesine izin vermek veya reddetmek için kullanılır. Auth modülleri, kullanıcının kimliğini doğrularken, aynı zamanda parola doğrulama politikalarını uygulayabilir ve parola değişikliği işlemlerini de gerçekleştirebilir. Örnek auth modülleri: pam_unix, pam_ldap.\n  Account modülleri: Kullanıcının hesap durumunu kontrol etmek için kullanılır. Account modülleri, kullanıcının hesap durumunu kontrol eder ve hesapları etkinleştirir veya devre dışı bırakır. Örnek account modülleri: pam_unix, pam_ldap.\n  Session modülleri: Kullanıcının oturum açma ve oturumu kapatma işlemlerini kontrol etmek için kullanılır. Session modülleri, kullanıcının oturum açma işlemi tamamlandığında, kullanıcının oturum açtığı tarih ve saat gibi oturum bilgilerini tutar. Örnek session modülleri: pam_unix, pam_limits.\n  Control-Flag #  İkinci sütun Control-Flag anlamına gelir.\n required: Modül başarısız olursa, oturum açma işlemi tamamlanamaz ve hata mesajı görüntülenir. requisite: required gibi davranır, ancak daha önceki bir modül başarısız olursa modülün kendisi çalıştırılmaz. sufficient: Bu modül, başarısız olursa bile oturum açma işlemi devam eder. optional: Bu modül her zaman başarılı olur ve herhangi bir hata mesajı vermez.  include direktifi, PAM yapılandırma dosyasında başka bir dosyayı dahil etmek için kullanılır. Bu, PAM modülleri için ayrı dosyalar kullanarak yapılandırmayı daha kolay hale getirir.\nÖrneğin, aşağıdaki yapılandırma dosyası, pam.d dizinindeki diğer dosyaları da dahil ederek SSH kimlik doğrulama işlemi için PAM modüllerini yapılandırır:\n# /etc/pam.d/sshd  auth required pam_sepermit.so auth include password-auth Modüller #  PAM modülleri, genellikle /lib/security/ veya /lib64/security/ dizinleri altında saklanır.\n  pam_unix: Bu modül, kullanıcı kimlik doğrulama bilgilerini /etc/passwd ve /etc/shadow dosyalarından alır.\n  pam_limits: Bu modül, bir kullanıcının sistem kaynaklarına erişimini sınırlandırmak için kullanılır.\n  pam_env: Bu modül, bir kullanıcının çevresel değişkenlerini belirlemek için kullanılır.\n  pam_deny: Bu modül, bir kullanıcının kimlik doğrulama işlemini reddeder.\n  pam_access : Bu modül, belirli bir kullanıcının erişimini sınırlandırmak için IP tabanlı kısıtlamalar sağlar.\n  pam_faillock : Bu modül, kullanıcının başarısız giriş denemelerini izler ve hesaplarını kilitler.\n  Örnek Kullanımlar #  faillock #  Aşağıdaki örnek, kullanıcının hesabını 3 başarısız giriş denemesinden sonra kilitler:\n# /etc/pam.d/password-auth  auth required pam_faillock.so preauth silent deny=3 unlock_time=600 auth required pam_faillock.so authfail deny=3 unlock_time=600 account required pam_faillock.so ...  İlk satır, preauth sırasında (pam_authenticate() çağrıldığında) pam_faillock modülünün kullanılmasını gerektirir. Bu, kullanıcının kimlik doğrulaması yapmadan önce sınırlandırma yapılacağı anlamına gelir. silent seçeneği, kullanıcıya kilitlendiğini bildirmemesini sağlar. deny=3 seçeneği, başarısız denemelerin sayısını 3 olarak ayarlar. Bu seçenek, üç başarısız deneme sonrasında kullanıcının hesabını kilitler. unlock_time=600 seçeneği, hesabın 10 dakika boyunca kilitli kalacağını belirtir.\n  İkinci satır, authfail sırasında (pam_authenticate() çağrıldığında) pam_faillock modülünün kullanılmasını gerektirir. Bu satır, kullanıcının kimlik doğrulamasını yaptıktan sonra başarısız olması durumunda sınırlandırma yapılacağını belirtir.\n  Son satır, account sırasında (pam_acct_mgmt() çağrıldığında) pam_faillock modülünün kullanılmasını gerektirir. Bu, hesabın kilidini açmak için kullanılır ve bir kullanıcının hesabının kilitli olup olmadığını kontrol eder.\n Kilitli Kullanıcılar #  Kilitli kullanıcıları görmek için;\n[root@localhost ~]# faillock test: When Type Source Valid 2023-05-09 15:06:19 RHOST 192.168.122.1 V 2023-05-09 15:06:24 RHOST 192.168.122.1 V 2023-05-09 15:06:28 RHOST 192.168.122.1 V Örnekte görüldüğü üzere test kullanıcısı kilitli durumuna düşmüştür.\nKilidi kaldırmak için;\nfaillock --reset --user test access #   Öncelikle, /etc/security/access.conf dosyasını açarak pam_access modülünü kullanarak hangi kullanıcıların erişimine izin vermek istediğinizi belirleyin. Bu dosyada, her bir kullanıcının izinleri farklı satırlarda belirtilir.\n  Ardından, /etc/pam.d/ dizinindeki gerekli servis dosyasını açarak pam_access modülünü etkinleştirin. Örneğin, SSH servisine erişim kontrolü eklemek istiyorsanız, sshd dosyasını açabilirsiniz.\n  pam_access modülünü kullanarak erişim kontrolü için gereken şartları belirtin. Bu örnekte, tüm kullanıcıların erişimine izin vermek için pam_access.so modülünü kullanıyoruz, ancak sadece belirli kullanıcılara erişim izni vermek isterseniz pam_access.so modülünü belirli kullanıcılara yönelik yapılandırabilirsiniz.\n # Herhangi bir host üzerinden root kullanıcısına bağlanabilir + : root : ALL  # user1 sadece 192.168.1.100 hostundan gelen bağlantılar kabul edilir + : user1 : 192.168.1.100  # user2 hiç bir hostan gelen istekleri kabul edemez - : user2 : ALL Bu ayarlamaları /etc/security/access.conf gerçekleştirdikten sshd servisine uygulamak istersek;\n# /etc/pam.d/sshd #%PAM-1.0 auth substack password-auth auth include postlogin account required pam_access.so ... limit #  Bu örnekte, bir kullanıcının açık olan dosya sayısını sınırlayacağız. Bunu yapmak için, /etc/security/limits.conf dosyasını düzenleyeceğiz. Bu dosya, pam_limits modülü tarafından kullanılır ve sistem kaynakları için farklı kısıtlamalar tanımlamamızı sağlar.\nÖnce, /etc/security/limits.conf dosyasını düzenleyin ve aşağıdaki satırları ekleyin:\ntest soft nofile 20 test hard nofile 21 test kullanıcısının açık olan dosya sayısını 20 ila 21 arasında sınırlayacaktır. soft limit, kullanıcıyı uyarırken hard limit, kullanıcının maksimum sayıya ulaşmasını engeller.\nDaha sonra, /etc/pam.d/sshd dosyasını düzenleyin ve aşağıdaki satırları ekleyin:\nsession required pam_limits.so Son olarak, test kullanıcısını oturum açtığınızda, dosya limit sayısına ulaşmak için ulimi kullanabilir.\n[test@localhost ~]$ ulimit -n 20 "},{"id":43,"href":"/linux-training/docs/102/script/switch/","title":"switch/case","section":"Script","content":"switch/case koşulu, birden fazla koşulun kontrol edilmesi gerektiğinde kullanılır. Örneğin, bir seçim menüsü oluşturmak isteyebilirsiniz. Aşağıdaki örnekte, kullanıcının girdiği sayıya göre bir işlem yapılır:\necho \u0026#34;1. İşlem\u0026#34; echo \u0026#34;2. İşlem\u0026#34; echo \u0026#34;3. İşlem\u0026#34; echo \u0026#34;Lütfen bir sayı girin:\u0026#34; read num  case $num in  1)  echo \u0026#34;İşlem 1\u0026#34;  ;;  2)  echo \u0026#34;İşlem 2\u0026#34;  ;;  3)  echo \u0026#34;İşlem 3\u0026#34;  ;;  *)  echo \u0026#34;Geçersiz sayı\u0026#34;  ;; esac Örnek #  #!/bin/bash # Bu script ile belirtilen ayın kaç gün çektiğini yazdırıyoruz.  echo \u0026#34;Hangi ay için gün sayısını öğrenmek istiyorsunuz? (1-12)\u0026#34; read ay  case $ay in  1 | 3 | 5 | 7 | 8 | 10 | 12)  echo \u0026#34;Bu ay 31 gün çeker.\u0026#34;  ;;  4 | 6 | 9 | 11)  echo \u0026#34;Bu ay 30 gün çeker.\u0026#34;  ;;  2)  echo \u0026#34;Bu ay 28 veya 29 gün çeker.\u0026#34;  ;;  *)  echo \u0026#34;Lütfen geçerli bir ay giriniz. (1-12)\u0026#34;  ;; esac Burada, kullanıcının girdiği ay değerine göre o ayın kaç gün çektiğini belirliyoruz. case yapısında, girilen ay değerini kontrol ediyoruz. Eğer girilen ay 1, 3, 5, 7, 8, 10 veya 12 ise, o ayın 31 gün çektiğini yazdırıyoruz.\n"},{"id":44,"href":"/linux-training/docs/101/kurulum/ubuntu-server/","title":"Ubuntu Kurulum","section":"Kurulum","content":"Ubuntu, özgür ve açık kaynaklı bir Linux işletim sistemidir. Mark Shuttleworth tarafından 2004 yılında piyasaya sürülmüştür ve temel olarak Debian GNU/Linux\u0026lsquo;a dayanmaktadır. Ubuntu, kullanıcı dostu bir arayüze, güçlü bir uygulama yelpazesine ve topluluk desteğine sahiptir.\nUbuntu, masaüstü, sunucu ve bulut bilgi işlemi için sürümler sunar. Ayrıca, Raspberry Pi gibi gömülü sistemler için de özel bir sürümü bulunmaktadır. Ubuntu, geniş bir yazılım yelpazesiyle birlikte gelir ve web tarayıcıları, ofis uygulamaları, grafik tasarım araçları, multimedya uygulamaları, geliştirme araçları ve daha pek çok uygulamayı içerir.\n"},{"id":45,"href":"/linux-training/docs/101/linux/da%C4%9F%C4%B1t%C4%B1mlar/","title":"Dağıtımlar","section":"Linux","content":"Linux dünyasında birçok farklı dağıtım mevcut ve bazıları diğerlerinden daha popüler veya yaygın olarak kullanılıyor. Debian ve Red Hat, bu dağıtımlardan ikisi. Debian, 1993 yılında Ian Murdock tarafından geliştirildi ve özellikle açık kaynaklı yazılım topluluğu için tasarlandı. Debian, kullanıcı dostu bir arayüz ve stabilite konusunda ün yapmıştır. Ayrıca, paket yöneticisi olan APT sayesinde, yazılım güncellemeleri ve yükleme işlemleri kolaydır. Debian, birçok farklı donanım mimarisi için mevcuttur ve farklı sürümleri var, örneğin stabil, testing ve unstable gibi. Red Hat, iş dünyası için tasarlanmış bir Linux dağıtımıdır. Red Hat Enterprise Linux (RHEL), özellikle büyük ölçekli işletmeler ve veri merkezleri tarafından kullanılır. RHEL, Red Hat tarafından desteklenir ve bakım ve güvenlik yamaları sağlar. Ayrıca, çeşitli iş yüklerini çalıştırmak için optimize edilmiş farklı sürümleri de mevcuttur, örneğin Red Hat OpenShift (konteyner platformu) ve Red Hat Virtualization (sanallaştırma çözümü). Debian ve Red Hat, Linux dünyasında birbirinden farklı ama önemli iki dağıtımdır. Debian, açık kaynaklı topluluğu için tasarlanmış bir dağıtım iken Red Hat, işletme ortamı için tasarlanmış bir dağıtımdır. Her ikisi de farklı özelliklere sahip olsa da, her ikisi de güvenilir, ölçeklenebilir ve özelleştirilebilir bir işletim sistemi sunar.\nCentos Projesi #  CentOS projesinin neden bittiği biraz karmaşık bir hikayeye dayanıyor. CentOS, Red Hat Enterprise Linux (RHEL) kod tabanına dayanan bir açık kaynaklı işletim sistemi dağıtımıdır. CentOS, RHEL kaynak kodunu kullanarak, özellikle sunucu ortamlarında kullanılmak üzere stabil ve güvenilir bir alternatif sunuyordu. Ancak, 2020 yılında Red Hat, CentOS\u0026rsquo;ün geleceğine yönelik bir değişiklik açıkladı. Red Hat, CentOS projesinin RHEL kaynak kodunu kullanarak yeni sürümler üretmeye devam edeceğini, ancak bu sürümlerin artık CentOS markası altında değil, Red Hat Enterprise Linux markası altında sunulacağını açıkladı. Böylece, CentOS kullanıcıları artık CentOS sürümleri için tam 10 yıl boyunca güvenlik güncellemeleri almayacaklardı. Bu açıklama, CentOS topluluğunda şok etkisi yarattı ve CentOS kullanıcıları, gelecekteki sürümler için alternatif bir plana sahip olmadan kalacaklarını düşündüler. Bu nedenle, CentOS kullanıcılarından bazıları, CentOS kaynak kodunu kullanarak bağımsız bir proje olan Rocky Linux\u0026rsquo;i başlatmaya karar verdiler. Rocky Linux, CentOS projesinin özellikle sunucu ortamlarında kullanımı için stabil ve güvenilir bir alternatif olarak hizmet vermeyi amaçlamaktadır. Sonuç olarak, CentOS projesinin bitmesi, Red Hat\u0026rsquo;ın CentOS\u0026rsquo;u RHEL markası altında bütünleştirmesi nedeniyle gerçekleşti. Ancak, CentOS kaynak kodunun kullanılmasıyla yeni bir proje olan Rocky Linux, CentOS kullanıcıları için bir alternatif sağlamaya çalışıyor.\nDiğer Dağıtımlar #  Gentoo: Kullanıcıların kendi sistemlerini özelleştirebilecekleri bir Linux dağıtımıdır. Gentoo, portage paket yöneticisi kullanarak kaynak kodundan derleme yapar. openSUSE: SUSE Linux\u0026rsquo;un açık kaynak kodlu sürümüdür. Hem masaüstü hem de sunucu kullanımı için tasarlanmıştır ve kullanıcı dostu bir arayüze sahiptir. CentOS Stream: CentOS projesinin sonlandırılmasından sonra, CentOS Stream ortaya çıktı. CentOS Stream, Red Hat Enterprise Linux\u0026rsquo;un gelecekteki sürümleri için bir test alanıdır ve son teknolojileri içerir. Manjaro: Arch Linux tabanlı bir kullanıcı dostu masaüstü Linux dağıtımıdır. Manjaro, kullanıcılara kolay kurulum, güncelleme ve yapılandırma seçenekleri sunar.\n"},{"id":46,"href":"/linux-training/docs/101/kullan%C4%B1c%C4%B1-ve-yetkilendirme/dosya-yetkilendirme/","title":"Dosya Yetkilendirme","section":"Kullanıcı Ve Yetkilendirme","content":"Bir Dosyanın Geçerli Sahibini ve Grup Sahipliğini Bulma #  Linux\u0026rsquo;ta bir dosya/dizinde yer alan izinleri gösteren güçlü ve muhtemelen tanıdık bir komut vardır. Bu, ls -l komutudur:\n[root@026ddc54726b opt]# ls -l -rwxr--r-- 1 root root 0 Apr 25 06:38 test.sh  ilk karakter dosya türünü belirtir. (-)  (-) dosya (d) dizin (I) sembolik link\n  2-4 karakter kullanıcı için izinlerini belirtir.(rwx) 5-7 karakter group izinlerini belirtir.(r\u0026ndash;) 8-10 karakter diğerizinleri belirtir. (r\u0026ndash;)  read read #  Okuma izni, bir dosyanın içeriğini açıp okumanıza izin verir. Ancak dosyada herhangi bir düzenleme veya değişiklik yapamazsınız.write write #  Yazma izni, bir dosyayı düzenlemenize, kaldırmanıza veya yeniden adlandırmanıza izin verir.execute execute #  Unix tipi sistemde, yürütme izni verilmeden bir programı çalıştıramaz chmod #  \u0026ldquo;chmod\u0026rdquo;, Linux ve diğer Unix tabanlı işletim sistemlerinde dosya ve klasör izinlerini değiştirmek için kullanılan bir komuttur.\n\u0026ldquo;chmod\u0026rdquo; komutu, üç farklı öğe kullanarak izinleri ayarlar:\n İzin verilen kullanıcı türü (örneğin, sahibi, grup üyeleri, diğer kullanıcılar) Hangi izinlerin verileceği (örneğin, okuma, yazma, çalıştırma) Hangi işlem yapılacağı (ekleme, kaldırma, ayarlama)  Octal Table\n   binary octal permissions     000 0 \u0026mdash;   001 1 \u0026ndash;x   010 2 -w-   011 3 -wx   100 4 r\u0026ndash;   101 5 r-x   110 6 rw-   111 7 rwx    chmod \u0026lt;groupName\u0026gt;=\u0026lt;permissions\u0026gt; \u0026lt;fileName\u0026gt; Örnek;\n[root@026ddc54726b opt]# ls -l -rw-r--r-- 1 root root 0 Apr 27 06:38 test.sh [root@026ddc54726b opt]# chmod u=rwx,g=rx,o=x test.sh [root@026ddc54726b opt]# ls -l -rwxr-x--x 1 root root 0 Apr 27 06:38 test.sh 777 = rwxrwxrwx 765 = rwxrw-r-x 654 = rw-r-xr-- Örnek;\n[root@026ddc54726b opt]# chmod 701 test.sh [root@026ddc54726b opt]# ls -l -rwx-----x 1 root root 0 Apr 27 06:38 test.sh chown #  \u0026ldquo;chown\u0026rdquo; komutu, Linux ve diğer Unix tabanlı işletim sistemlerinde bir dosyanın veya klasörün sahibini değiştirmek için kullanılır.\nchown \u0026lt;user_name\u0026gt;:\u0026lt;group_name\u0026gt; \u0026lt;file_name\u0026gt; Örnek;\n[root@026ddc54726b opt]# chown new_user2:db_admins test.sh [root@026ddc54726b opt]# ls -l test.sh -rwx-----x 1 new_user2 db_admins 0 Apr 27 06:38 test.sh chgrp #  Linux ve diğer Unix tabanlı işletim sistemlerinde bir dosyanın veya klasörün grubunu değiştirmek için kullanılır. Bu komut, dosya grubunu değiştirmenin yanı sıra, dosya sahibini değiştirmez.\nchown \u0026lt;group_name\u0026gt; \u0026lt;file_name\u0026gt; Örnek;\n[root@026ddc54726b opt]# chgrp root test.sh [root@026ddc54726b opt]# ls -l test.sh -rwx-----x 1 new_user2 root 0 Apr 27 06:38 test.sh "},{"id":47,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/resolv/","title":"resolv.conf","section":"Ağ Yönetimi","content":"/etc/resolv.conf, Unix benzeri işletim sistemlerinde DNS (Domain Name System) yapılandırmasını ayarlamak için kullanılan bir dosyadır. Bu dosya, DNS sorguları yapmak için kullanılan DNS sunucularının IP adreslerini ve diğer yapılandırma seçeneklerini içerir.\nÖrneğin, bir bilgisayarın /etc/resolv.conf dosyasında aşağıdaki satırlar bulunabilir:\nnameserver 8.8.8.8 nameserver 8.8.4.4 Bu, bilgisayarın DNS sorgularını Google Public DNS sunucularına yönlendireceğini belirtir. Başka seçenekler de vardır, örneğin, arama alanlarını belirlemek veya sorguları sınırlamak için yerel bir DNS sunucusu kullanmak gibi. Bu dosya, kullanıcıların DNS yapılandırmasını kolayca değiştirmelerini sağlar.\n"},{"id":48,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/hosts/","title":"hosts.conf","section":"Ağ Yönetimi","content":"/etc/hosts, Unix benzeri işletim sistemlerinde kullanılan bir dosyadır ve IP adresleri ile alan adları arasında elle yapılan eşleştirmeleri sağlar. Bu dosya, bir bilgisayarın DNS sunucularını kullanmadan, yerel olarak alan adlarına IP adresleri atamak için kullanılabilir.\nÖrneğin, /etc/hosts dosyasında aşağıdaki satırlar bulunabilir:\n127.0.0.1 localhost 192.168.1.10 myserver.com Bu, bilgisayarın yerel DNS sunucusunu kullanmadan, \u0026ldquo;localhost\u0026rdquo; adının her zaman 127.0.0.1 IP adresine eşit olduğunu ve \u0026ldquo;myserver.com\u0026rdquo; adının 192.168.1.10 IP adresine eşit olduğunu belirtir.\n/etc/hosts dosyası, bir bilgisayarın yerel ağındaki diğer bilgisayarları adlandırmak veya test amaçlı web sitelerini yönlendirmek gibi çeşitli amaçlar için kullanılabilir. Ancak, büyük ağlarda veya Internet\u0026rsquo;teki geniş kullanıcı tabanına sahip sitelerde kullanımı sınırlıdır, çünkü bu durumlarda, DNS sunucuları IP adresi ve alan adı eşleştirmelerini daha etkili bir şekilde yönetir.\nTCP Wrapper TCP Wrapper, ağ servisleri için ağ erişim kontrolü ve günlük tutma özellikleri sağlayan bir yazılım uygulamasıdır. Gelen ağ trafiğini bağlanan ana bilgisayarın IP adresine göre filtrelemenize olanak tanıyan bir güvenlik aracıdır.  "},{"id":49,"href":"/linux-training/docs/101/crontab/crontab/","title":"crontab","section":"Crontab","content":"Crontab, belirli aralıklarla çalıştırılmak üzere önceden planlanmış görevleri yönetmek için kullanılan bir programdır. Crontab, sistem yöneticilerinin belirli görevleri otomatikleştirmelerine ve zamanlarını daha verimli bir şekilde kullanmalarına olanak tanır. Bu nedenle, Crontab, Linux sistemi yönetimi için önemli bir araçtır.\nCrontab, ayrı bir dosya olarak tutulur ve crontab komutu kullanılarak düzenlenir. Crontab dosyası, kullanıcı adı ve çalıştırılacak görevlerin bir listesi içerir. Görevler, dakika, saat, gün, ay ve haftanın hangi günü gibi zamanlama parametreleriyle belirlenir.\nCrontab komutu, çeşitli parametrelerle kullanılabilir. En sık kullanılan parametreler aşağıda listelenmiştir:\n -l: Mevcut crontab dosyasını görüntüler -e: Crontab dosyasını düzenler -r: Mevcut crontab dosyasını kaldırır Crontab dosyası aşağıdaki formatı takip eder:  * * * * * /path/to/command arg1 arg2 - - - - - | | | | | | | | | ----- Haftanın hangi günü (0 - 7) | | | ------- Ayın hangi günü (1 - 31) | | --------- Ay (1 - 12) | ----------- Saat (0 - 23) ------------- Dakika (0 - 59) Örneğin, \u0026ldquo;30 dakikada bir /home/user/backup.sh dosyasını çalıştır\u0026rdquo; şeklinde bir crontab görevi aşağıdaki gibi görünebilir:\n*/30 * * * * /home/user/backup.sh Bu görev, her saat başı 0 ve 30 dakikalarında çalıştırılacaktır.\n"},{"id":50,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/dig/","title":"dig","section":"Ağ Yönetimi","content":"dig, Domain Information Groper (Alan Bilgisi Kazıyıcısı) olarak adlandırılan, DNS (Domain Name System) sorguları yapmak için kullanılan bir komut satırı aracıdır. Unix ve Unix benzeri işletim sistemlerinde kullanılabilir.\ndig, DNS sorguları yaparak belirtilen bir alan adının IP adresi veya tersi bir DNS sorgusu yaparak bir IP adresinin alan adı gibi bilgileri almanıza olanak tanır. Ayrıca, DNS sunucularını doğrulamak ve bağlantı sorunlarını gidermek için de kullanılabilir.\nÖrneğin, aşağıdaki komut bir alan adının IP adresini almak için kullanılabilir:\n[ergunbilsel@localhost linux-101]$ dig e-devlet.gov.tr  ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.13 \u0026lt;\u0026lt;\u0026gt;\u0026gt; e-devlet.gov.tr ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 19898 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1  ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 65494 ;; QUESTION SECTION: ;e-devlet.gov.tr.\tIN\tA  ;; ANSWER SECTION: e-devlet.gov.tr.\t5029\tIN\tA\t94.55.118.20  ;; Query time: 0 msec ;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP) ;; WHEN: Fri Apr 28 09:24:23 +03 2023 ;; MSG SIZE rcvd: 60 veya aşağıdaki komut bir IP adresinin alan adını almak için kullanılabilir:\n[ergunbilsel@localhost linux-101]$ dig -x 94.55.118.20  ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.13 \u0026lt;\u0026lt;\u0026gt;\u0026gt; -x 94.55.118.20 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 30753 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1  ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 65494 ;; QUESTION SECTION: ;20.118.55.94.in-addr.arpa.\tIN\tPTR  ;; ANSWER SECTION: 20.118.55.94.in-addr.arpa. 7087\tIN\tPTR\tptr-20.turkiye.gov.tr.  ;; Query time: 0 msec ;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP) ;; WHEN: Fri Apr 28 09:25:41 +03 2023 ;; MSG SIZE rcvd: 89 "},{"id":51,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/static-ip/","title":"static IP","section":"Ağ Yönetimi","content":"\u0026ldquo;nmcli\u0026rdquo; (Network Manager Command Line Interface), Linux işletim sistemlerinde Network Manager\u0026rsquo;ı yönetmek için kullanılan bir komut satırı arayüzüdür. Bu araç, kablosuz ve kablolu ağ bağlantılarını yapılandırmak, yönetmek ve izlemek için kullanılabilir.\n\u0026ldquo;nmcli\u0026rdquo; aracı, ağ bağlantılarını yapılandırmak, düzenlemek ve silmek için kullanılabilir. Ayrıca, ağ bağlantılarını listelemek, bağlantı durumunu kontrol etmek ve ağ profillerini yönetmek için de kullanılabilir. Bu araç, komut satırından çalıştırıldığı için otomasyon ve betikleme için de uygundur.\n Önceden, NetworkManager ağ profillerini ifcfg biçiminde saklıyordu. bu dizinde (/etc/sysconfig/network-scripts/). Ancak, ifcfg format kullanımdan kaldırıldı.  Öncelikle mevcut network kartlarını görüntüleyelim;\n[root@localhost ~]# nmcli connection show NAME UUID TYPE DEVICE enp1s0 081eac1c-b9ab-3f1f-ba81-4acfbca5e469 ethernet enp1s0 lo 4f3307e7-8e4f-4817-bade-89180fd581a1 loopback lo Yeni bir nic profili tanımlayalım;\nroot@localhost ~]# nmcli con add type ethernet con-name \u0026#34;static-ip\u0026#34; ifname enp1s0 ipv4.addresses 192.168.122.150/24 gw4 192.168.122.1 Connection \u0026#39;static-ip\u0026#39; (be6f4767-448e-4daa-89b6-55e335c09071) successfully added. Mevcut profilleri görüntüliyelim;\n[root@localhost ~]# nmcli connection show NAME UUID TYPE DEVICE enp1s0 081eac1c-b9ab-3f1f-ba81-4acfbca5e469 ethernet enp1s0 lo 4f3307e7-8e4f-4817-bade-89180fd581a1 loopback lo static-ip be6f4767-448e-4daa-89b6-55e335c09071 ethernet -- static-ip isminde bir profil oluştuğunu görmekteyiz. Bu profile DNS ayaralarını ekliyoruz.\n[root@localhost ~]# nmcli con mod static-ip ipv4.dns \u0026#34;8.8.8.8 8.8.4.4\u0026#34; oluşturdğumuz kartı aktif hale getiriyoruz.\n[root@localhost ~]# nmcli con up static-ip ifname enp1s0 Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/6) Enp1s0 ağ arayüzümüze başka bir IP adresi ekledik. IP adresinin başarıyla eklendiğini doğrulamak için ip komutunu çalıştıracağız:\n[root@localhost ~]# ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00  inet 127.0.0.1/8 scope host lo  valid_lft forever preferred_lft forever  inet6 ::1/128 scope host  valid_lft forever preferred_lft forever 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000  link/ether 52:54:00:1e:33:52 brd ff:ff:ff:ff:ff:ff  inet 192.168.122.150/24 brd 192.168.122.255 scope global noprefixroute enp1s0  valid_lft forever preferred_lft forever  inet 192.168.122.10/24 brd 192.168.122.255 scope global secondary dynamic noprefixroute enp1s0  valid_lft 3512sec preferred_lft 3512sec  inet6 fe80::2eb2:fd3c:7c3f:a8a3/64 scope link noprefixroute  valid_lft forever preferred_lft forever [root@localhost ~]# Up \u0026amp; Down #  Bağlantıyı etkinleştirerek veya devre dışı bırakarak nasıl yönetebileceğinizi keşfedeceğiz. Bir bağlantıyı devre dışı bırakmak veya devre dışı bırakmak için şu komutu çalıştırın:\nnmcli con down id \u0026#34;static-ip\u0026#34; ifname enp1s0 nmcli con up id \u0026#34;static-ip\u0026#34; ifname enp1s0 edit #  Oluşturmuş olduğumuz profili editlemek için;\n[root@localhost network-scripts]# nmcli connection edit static-ip nmcli\u0026gt; set ipv4.method manual nmcli\u0026gt; set ipv4.address 192.168.122.151/24 nmcli\u0026gt; save Config File #  Yapılan tüm değişiklikler /etc/NetworkManager/system-connections/ dizininde tutulmaktadır.\n[root@localhost network-scripts]# cat /etc/NetworkManager/system-connections/static-ip.nmconnection [connection] id=static-ip uuid=be6f4767-448e-4daa-89b6-55e335c09071 type=ethernet interface-name=enp1s0 timestamp=1682674842  [ethernet]  [ipv4] address1=192.168.122.150/24,192.168.122.1 address2=192.168.122.151/24 dns=8.8.8.8;8.8.4.4; method=manual  [ipv6] addr-gen-mode=default method=auto  [proxy] "},{"id":52,"href":"/linux-training/docs/101/fstab/fstab/","title":"fstab","section":"Fstab","content":"fstab (File System Table) Linux işletim sistemi dosya sistemi yönetiminde kullanılan bir dosyadır. Bu dosya, sistemin açılış sırasında otomatik olarak bağlanması gereken dosya sistemlerini belirler. Bu dosyadaki girdiler, işletim sistemi tarafından otomatik olarak yüklenir.\nfstab dosyası, dosya sistemi türleri ve parametreleri belirleyerek sistemdeki dosya sistemlerinin nasıl monte edileceğini belirler. Ayrıca bu dosya, sistem açılırken otomatik olarak monte edilecek dosya sistemleri, hangi kullanıcıların bunu yapabileceği, nasıl yapılandırılacağı ve bağlama seçenekleri hakkında bilgi içerir.\nfstab dosyası, aşağıdaki gibi yapılandırılır:\n\u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt;  : bağlanacak dosya sisteminin dosya yolunu veya etiketini belirtir. : dosya sisteminin bağlanacağı dizin yolunu belirtir. : dosya sistemi türünü belirtir (örn. ext4, nfs, vfat). : dosya sistemi ile ilgili seçenekleri belirtir. : dosya sisteminin yedeklenmesi gerekip gerekmediğini belirtir. : dosya sisteminin dosya sistemlerinin sırayla nasıl kontrol edileceğini belirtir.  Örnek fstab girdileri:\n/dev/sda2 none swap sw 0 0 --- /dev/sda2: Swap bölümünün bir ismi.  none: Swap dosyası için bir dosya sistemi tanımlayıcısı.  swap: Dosya sistemi türü.  sw: Swap bölümünü kullanmaya izin veren seçenekler.  0: Dosya sistemi önyükleme sırasında yedekleme yapılmayacak.  0: Swap bölümü için dosya sistemi geçerlilik kontrolü yapmayacak. ---  /dev/sda1 / ext4 errors=remount-ro 0 1  --- /dev/sda1: Kök dosya sistemi bölümünün bir ismi.  /: Kök dosya sisteminin yerini belirtir.  ext4: Dosya sistemi türü.  errors=remount-ro: Eğer sistemde bir hata olursa, dosya sistemi otomatik olarak okunur-yazılır bir moda geçirilir.  0: Dosya sistemi önyükleme sırasında yedekleme yapılmayacak.  1: Kök dosya sistemi, diğer dosya sistemlerinden önce önyükleme yapacak. ---   /dev/sda3 /home ext4 defaults 0 2  --- /dev/sda3: Kullanıcıların ev dizinlerinin bulunduğu dosya sisteminin bir ismi.  /home: Ev dizinlerinin bulunduğu yer.  ext4: Dosya sistemi türü.  defaults: Dosya sistemi için varsayılan seçenekler.  0: Dosya sistemi önyükleme sırasında yedekleme yapılmayacak.  2: Ev dizinleri diğer dosya sistemlerinden sonra önyükleme yapacak. --- "},{"id":53,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/traceroute/","title":"traceroute","section":"Ağ Yönetimi","content":"Traceroute, ağdaki bir hedefe erişmek için verilerin nasıl ilerlediğini gösteren bir ağ teşhis aracıdır. Traceroute, paketlerin izlenebilirliğini sağlamak için ICMP (Internet Control Message Protocol) ve TTL (Time to Live) kullanır. Traceroute, bir hedefe yönelik veri paketleri gönderir ve bu paketlerin yolu boyunca hangi ağ cihazlarından geçtiğini ve hangi cihazlarda gecikme yaşandığını takip eder.\nTraceroute, bir hedefe yönelik veri paketleri gönderir ve her paketin TTL değerini arttırarak gönderir. TTL, her yönlendirici (router) geçişinde bir azaltma işlemi uygular. Eğer bir paket belirli bir yönlendirici tarafından alınır ve TTL değeri sıfıra düşerse, yönlendirici paketi yok sayar ve ICMP mesajıyla geri gönderir. Traceroute, bu ICMP mesajlarını kullanarak, paketin yolu boyunca geçtiği yönlendiricilerin IP adreslerini ve gecikme sürelerini hesaplar.\nTraceroute, genellikle ağ bağlantı sorunlarını tespit etmek ve ağdaki yavaş noktaları belirlemek için kullanılır. Traceroute sonuçları, ağ yöneticileri tarafından kullanılarak ağ sorunlarını gidermek ve ağ performansını optimize etmek için kullanılabilir.\nroot@localhost network-scripts]# traceroute google.com traceroute to google.com (142.251.140.14), 30 hops max, 60 byte packets  1 _gateway (192.168.122.1) 0.256 ms 0.158 ms 0.120 ms  2 192.168.1.1 (192.168.1.1) 1.570 ms 1.712 ms 1.852 ms  3 10.76.0.1 (10.76.0.1) 5.475 ms 5.469 ms 5.525 ms  4 10.36.117.186 (10.36.117.186) 6.638 ms 6.827 ms 6.594 ms  5 10.54.255.14 (10.54.255.14) 6.642 ms 6.591 ms 6.676 ms  6 10.54.255.49 (10.54.255.49) 7.799 ms 7.022 ms 6.895 ms  7 10.40.155.155 (10.40.155.155) 10.944 ms 9.379 ms 10.40.155.156 (10.40.155.156) 9.531 ms  8 10.40.141.73 (10.40.141.73) 11.124 ms * *  9 10.40.168.31 (10.40.168.31) 6.627 ms 6.596 ms 6.634 ms 10 72.14.212.96 (72.14.212.96) 28.006 ms 27.812 ms 27.970 ms 11 * * * 12 216.239.49.198 (216.239.49.198) 28.838 ms 108.170.250.177 (108.170.250.177) 27.379 ms 172.253.65.42 (172.253.65.42) 27.878 ms 13 142.251.246.235 (142.251.246.235) 24.532 ms 108.170.250.178 (108.170.250.178) 106.250 ms 108.170.250.163 (108.170.250.163) 27.931 ms 14 sof04s04-in-f14.1e100.net (142.251.140.14) 24.847 ms 142.251.242.231 (142.251.242.231) 28.510 ms sof04s04-in-f14.1e100.net (142.251.140.14) 24.730 ms Tablodaki çıktı, Google.com\u0026rsquo;a bir traceroute işlemi gerçekleştirilerek elde edilmiştir.\nİlk sütunda \u0026ldquo;hop\u0026rdquo; numaraları yer alır, yani verilerin geçtiği ara noktaların sayısı. \u0026ldquo;30 hops max\u0026rdquo; ifadesi ise, traceroute işleminde en fazla 30 ara noktaya kadar izlenebileceğini gösterir.\nİkinci sütunda, traceroute işlemi sırasında her ara noktanın IP adresi yer alır. Örneğin, ilk ara nokta \u0026ldquo;_gateway\u0026rdquo; adıyla tanımlanmış ve IP adresi 192.168.122.1\u0026rsquo;dir.\nÜçüncü sütunda, her ara noktaya veri paketi gönderilmesi için geçen süreler (ms) yer alır. Örneğin, ilk ara noktaya veri paketi gönderilmesi 0.256 ms sürmüştür.\nÇıktıdaki bilgiler, veri paketlerinin hangi ağ cihazlarından geçtiğini ve hangi cihazlarda gecikme yaşandığını takip etmemizi sağlar. Örneğin, ilk ara nokta \u0026ldquo;_gateway\u0026rdquo; adıyla tanımlanmış ve bu noktada veri paketleri hemen hemen hiç gecikme yaşamamıştır. Diğer ara noktalarda ise değişken gecikmeler yaşanmıştır.\nSon sütunda, her ara noktanın ismi ve IP adresi yer alır. Örneğin, son ara nokta \u0026ldquo;sof04s04-in-f14.1e100.net\u0026rdquo; adıyla tanımlanmış ve IP adresi 142.251.140.14\u0026rsquo;tür. Bu, Google\u0026rsquo;ın sunucularından biridir.\nTraceroute işlemi, ağ sorunlarını tespit etmek ve ağ performansını optimize etmek için kullanılabilir. Bu çıktıda, Google sunucusuna ulaşmak için 14 ara noktanın geçilmesi gerektiği görülüyor ve bazı noktalarda gecikme yaşandığı gözlemleniyor. Ancak genel olarak, veri paketleri hızlı bir şekilde Google sunucusuna ulaşmış görünüyor.\n*** traceroute çıktısında \u0026ldquo;timeout\u0026rdquo; durumunu ifade eder. Yani, bir paket hedefe ulaşamadığında, bir sonraki hop\u0026rsquo;a geçilir ve bu noktaya kadar olan tüm hop\u0026rsquo;lar başarıyla geçilmiş olarak kabul edilir.  "},{"id":54,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/ethtool/","title":"ethtool","section":"Ağ Yönetimi","content":"ethtool bir Linux aracıdır ve Ethernet kartının ayarlarını değiştirmek için kullanılır. ethtool aracı, bir Ethernet kartının desteklediği özellikleri listelemek, NIC ayarlarını görüntülemek ve yapılandırmak için kullanılabilir.\nBirkaç kullanışlı ethtool komutu şunlardır:\n ethtool enp1s0: enp1s0 arayüzündeki NIC ayarlarını gösterir. ethtool -i enp1s0: enp1s0 arayüzündeki sürücü bilgilerini gösterir. ethtool -S enp1s0: enp1s0 arayüzündeki NIC istatistiklerini gösterir. ethtool -A enp1s0 autoneg on: enp1s0 arayüzündeki otomatik anlaşma özelliğini açar. ethtool -s enp1s0 speed 1000 duplex full: enp1s0 arayüzündeki hızı 1000Mbps ve tam çift yönlü (full duplex) modunu ayarlar.  [root@localhost network-scripts]# ethtool enp1s0 Settings for enp1s0: \tSupported ports: [ ] \tSupported link modes: Not reported \tSupported pause frame use: No \tSupports auto-negotiation: No \tSupported FEC modes: Not reported \tAdvertised link modes: Not reported \tAdvertised pause frame use: No \tAdvertised auto-negotiation: No \tAdvertised FEC modes: Not reported \tSpeed: Unknown! \tDuplex: Unknown! (255) \tAuto-negotiation: off \tPort: Other \tPHYAD: 0 \tTransceiver: internal \tLink detected: yes [root@localhost network-scripts]# ethtool -i enp1s0 driver: virtio_net version: 1.0.0 firmware-version: expansion-rom-version: bus-info: 0000:01:00.0 supports-statistics: yes supports-test: no supports-eeprom-access: no supports-register-dump: no supports-priv-flags: no "},{"id":55,"href":"/linux-training/docs/102/script/sed/","title":"sed","section":"Script","content":"Sed (Stream Editor) bir metin düzenleyicisidir. Temel olarak, bir metin akışının (dosya veya bir veri akışı gibi) içeriğini değiştirmek için kullanılır. Genellikle komut satırı aracılığıyla kullanılır ve birçok işletim sisteminde öntanımlı olarak yüklüdür.\nSed, düzenli ifadeler (regular expressions) kullanarak metin akışını işleyebilir. İşlem yaparken, orijinal veri akışını bozmadan yeni bir metin akışı oluşturur. Sed ayrıca, çeşitli sed komutları ve argümanları aracılığıyla, metin akışını filtrelemek, düzenlemek, eşleştirmek, değiştirmek, sıralamak ve biçimlendirmek gibi çeşitli işlemler gerçekleştirebilir.\n Metin dosyasında tüm \u0026ldquo;Lorem\u0026rdquo; kelimesini \u0026ldquo;lrm\u0026rdquo; ile değiştirme:  [root@localhost ~]# cat lorem-ipsum.txt Lorem Ipsum, dizgi ve baskı endüstrisinde kullanılan mıgır metinlerdir. Lorem Ipsum, adı bilinmeyen bir matbaacının bir hurufat numune kitabı oluşturmak üzere bir yazı galerisini alarak karıştırdığı 1500\u0026#39;lerden beri endüstri standardı sahte metinler olarak kullanılmıştır. Beşyüz yıl boyunca varlığını sürdürmekle kalmamış, aynı zamanda pek değişmeden elektronik dizgiye de sıçramıştır. 1960\u0026#39;larda Lorem Ipsum pasajları da içeren Letraset yapraklarının yayınlanması ile ve yakın zamanda Aldus PageMaker gibi Lorem Ipsum sürümleri içeren masaüstü yayıncılık yazılımları ile popüler olmuştur. [root@localhost ~]# sed \u0026#39;s/Lorem/lrm/g\u0026#39; lorem-ipsum.txt lrm Ipsum, dizgi ve baskı endüstrisinde kullanılan mıgır metinlerdir. lrm Ipsum, adı bilinmeyen bir matbaacının bir hurufat numune kitabı oluşturmak üzere bir yazı galerisini alarak karıştırdığı 1500\u0026#39;lerden beri endüstri standardı sahte metinler olarak kullanılmıştır. Beşyüz yıl boyunca varlığını sürdürmekle kalmamış, aynı zamanda pek değişmeden elektronik dizgiye de sıçramıştır. 1960\u0026#39;larda lrm Ipsum pasajları da içeren Letraset yapraklarının yayınlanması ile ve yakın zamanda Aldus PageMaker gibi lrm Ipsum sürümleri içeren masaüstü yayıncılık yazılımları ile popüler olmuştur. Yukarıdaki çıktıda metin\u0026rsquo;in içerisinde \u0026ldquo;Lorem\u0026rdquo; kelimesini \u0026ldquo;lrm\u0026rdquo; olarak değiştirip metni basmıştır fakat metnin orjinal yapısını değiştirmemiştir.\n Dosyadan belirli bir satırdan başlayarak tüm satırları silme:  [root@localhost ~]# sed \u0026#39;3,$d\u0026#39; lorem-ipsum.txt Lorem Ipsum, dizgi ve baskı endüstrisinde kullanılan mıgır metinlerdir. Lorem Ipsum, adı bilinmeyen bir matbaacının bir hurufat numune kitabı oluşturmak üzere bir yazı galerisini alarak karıştırdığı 1500\u0026#39;lerden beri endüstri standardı sahte metinler olarak kullanılmıştır. Yukarıdaki çıktıda 3\u0026rsquo;üncü satırdan dan başlayarak tüm satırları sildiğini görüyoruz.\n Belirli bir kelimeyi içeren satırların yerine başka bir kelime eklemek:  [root@localhost ~]# sed \u0026#39;/Lorem/c\\Yeni Satır\u0026#39; lorem-ipsum.txt Yeni Satır Yeni Satır Beşyüz yıl boyunca varlığını sürdürmekle kalmamış, aynı zamanda pek değişmeden elektronik dizgiye de sıçramıştır. Yeni Satır Yukarıdaki örnekte \u0026ldquo;Lorem\u0026rdquo; kelimesi başka bir satır eklendiğini görüyoruz.\nsed komutu, yaptığı değişiklikleri dosyada otomatik olarak kaydetmez, ancak çıktıyı başka bir dosyaya yönlendirmenizi veya dosyayı değiştirip değiştirmediğinizi kontrol etmenizi sağlar.\nÖrneğin, bir dosyadaki elma kelimesini armut ile değiştirmek ve çıktıyı output.txt dosyasına kaydetmek için aşağıdaki komutu kullanabilirsiniz:\nsed \u0026#39;s/elma/armut/g\u0026#39; input.txt \u0026gt; output.txt Ayrıca, sed komutunu kullanarak dosyanın kendisini değiştirebilirsiniz. Bu durumda, -i seçeneğini kullanmalısınız. Örneğin:\nsed -i \u0026#39;s/elma/armut/g\u0026#39; input.txt "},{"id":56,"href":"/linux-training/docs/102/script/awk/","title":"awk","section":"Script","content":"Awk, Linux ve Unix tabanlı sistemlerde bulunan bir komut satırı aracıdır. Adını oluşturan AWK, komutun yaratıcısı Alfred Aho, Peter Weinberger ve Brian Kernighan\u0026rsquo;ın isimlerinin baş harflerinden gelir. Awk, metin dosyalarında belirli bir düzen içinde arama yapmak, dosyalardan belirli verileri çekmek, düzenlemek ve filtrelemek için kullanılır.\nAwk, genellikle metin dosyalarındaki belirli satırları veya sütunları seçmek için kullanılır. Awk komutları, bir veya daha fazla eylem ve bir veya daha fazla desenden oluşur. Desenler, seçilen verilerin hangi kriterlere göre seçileceğini belirlerken, eylemler seçilen verilerin ne yapılacağını belirler.\n Metin dosyasında belirli bir kelimeyi arama ve satır numaralarını yazdırma:  [root@localhost ~]# awk \u0026#39;/Hakkıdır/ {print NR}\u0026#39; istiklal-marsı.txt 8 39 40 Yukarıda \u0026ldquo;Hakkıdır\u0026rdquo; kelimesinin istiklal-marsı.txt içerisinde hangi satırlarda bulunduğunun çıktısını görmekteyiz.\n Dosyadaki belirli bir satırdan itibaren yazdırma:  [root@localhost ~]# awk \u0026#39;NR\u0026gt;=5 \u0026amp;\u0026amp; NR\u0026lt;=10\u0026#39; istiklal-marsı.txt Çatma, kurban olayım çehreni ey nazlı hilâl! Kahraman ırkıma bir gül… ne bu şiddet bu celâl? Sana olmaz dökülen kanlarımız sonra helâl, Hakkıdır, Hakk’a tapan, milletimin istiklâl. Ben ezelden beridir hür yaşadım, hür yaşarım. Hangi çılgın bana zincir vuracakmış? Şaşarım! Yukarıda 5 ve 10 satır arasındaki yerlerin yazdırıldığını görüyoruz.\n Dosyadaki belirli satır ve sütünlarını yazdırma:  [root@localhost ~]# awk \u0026#39;NR\u0026gt;=5 \u0026amp;\u0026amp; NR\u0026lt;=10 {print $1,$3}\u0026#39; istiklal-marsı.txt Çatma, olayım Kahraman bir Sana dökülen Hakkıdır, tapan, Ben beridir Hangi bana "},{"id":57,"href":"/linux-training/docs/101/a%C4%9F-y%C3%B6netimi/terminoloji/","title":"Terminoloji","section":"Ağ Yönetimi","content":"OSI #  OSI (Open Systems Interconnection) modeli, ağ iletişiminde kullanılan standart bir referans modelidir. OSI modeli, farklı ağ cihazları arasındaki iletişimi standartlaştırmak ve uyumluluğu sağlamak için tasarlanmıştır.\nOSI modeli, 7 farklı katmandan oluşur ve her katman, belirli bir işlevi yerine getirir. Bu katmanlar şunlardır:\n  Fiziksel Katman (Physical Layer): Bu katman, ağ cihazları arasındaki verilerin fiziksel ortamda taşınmasından sorumludur. Veriler, elektrik sinyalleri, radyo dalgaları veya fiber optik kablolama gibi farklı fiziksel ortamlarda taşınabilir.\n  Veri Bağlantı Katmanı (Data Link Layer): Bu katman, fiziksel katmanda taşınan verilerin parçalanmasını, hata düzeltmesini ve denetimini yapar. Bu katman, ağ cihazları arasında veri paketleri göndermek için kullanılan çerçeveleri yönetir.\n  Ağ Katmanı (Network Layer): Bu katman, veri paketlerinin ağ üzerindeki yönlendirmesinden sorumludur. Bu katmanda, veri paketleri yönlendiriciler aracılığıyla diğer ağlara iletilir.\n  Taşıma Katmanı (Transport Layer): Bu katman, veri akışının yönetiminden sorumludur ve veri akışını segmentlere ayırır. Bu katmanda, hata kontrolü yapılır ve veri akışının düzenlenmesi sağlanır.\n  Oturum Katmanı (Session Layer): Bu katman, veri iletişimindeki oturum yönetimini sağlar. Bu katmanda, veri akışı, belirli bir zaman aralığında yapılır.\n  Sunum Katmanı (Presentation Layer): Bu katman, verilerin sunulması için yapılandırma ve kodlama yöntemlerini tanımlar. Bu katmanda, verilerin dönüştürülmesi ve kodlanması yapılır.\n  Uygulama Katmanı (Application Layer): Bu katman, uygulamalar arasındaki veri alışverişinden sorumludur. Bu katmanda, e-posta, dosya paylaşımı, web sayfaları gibi farklı uygulamalar arasındaki iletişim gerçekleştirilir.\n  Her katman, üstündeki ve altındaki katmanlarla belirli bir protokol kullanarak iletişim kurar. OSI modeli, farklı ağ cihazları arasındaki iletişimi standartlaştırdığı için, farklı protokollerin ve cihazların birbirleriyle uyumlu çalışmasını sağlar.\nDOD #  \u0026ldquo;DOD modeli\u0026rdquo; terimi, ağ güvenliği için kullanılan bir modeli ifade eder. Bu model, \u0026ldquo;Department of Defense\u0026rdquo; (Savunma Bakanlığı) tarafından geliştirilmiş ve kullanılan bir modeldir.\nDOD modeli, ağ güvenliği için çeşitli katmanlardan oluşur. Bu katmanlar, fiziksel güvenlik, kişisel güvenlik, işletim sistemleri güvenliği, ağ güvenliği ve uygulama güvenliği gibi konuları kapsar.\nDOD modelinin 7 katmanı şunlardır:\n  Fiziksel güvenlik: Fiziksel güvenlik, ağ kaynaklarına fiziksel erişimi kısıtlamak ve korumakla ilgilidir. Bu katmanda, fiziksel erişimi kısıtlayan duvarlar, kapılar, kilitler ve benzeri cihazlar kullanılır.\n  Kişisel güvenlik: Kişisel güvenlik, ağ kaynaklarına erişim izni olan kişilerin belirlenmesi ve bu kişilerin yetkilerinin yönetilmesiyle ilgilidir. Bu katmanda, kullanıcı adları, şifreler ve benzeri kimlik doğrulama yöntemleri kullanılır.\n  İşletim sistemi güvenliği: İşletim sistemi güvenliği, ağa bağlı cihazlardaki işletim sistemlerinin güvenliğini sağlamayı amaçlar. Bu katmanda, işletim sistemi yamalarının uygulanması, antivirüs yazılımı ve diğer güvenlik araçları kullanılır.\n  Ağ güvenliği: Ağ güvenliği, ağ kaynaklarına yapılan saldırıları engellemek ve ağa erişim izni olan cihazların güvenliğini sağlamakla ilgilidir. Bu katmanda, güvenlik duvarları, sanal özel ağlar (VPN\u0026rsquo;ler), ağ tabanlı saldırı tespit sistemleri (IDS\u0026rsquo;ler) ve benzeri cihazlar kullanılır.\n  İletişim güvenliği: İletişim güvenliği, ağ üzerinden iletilen verilerin gizliliğini, bütünlüğünü ve doğruluğunu sağlamayı amaçlar. Bu katmanda, şifreleme, SSL/TLS gibi protokoller ve benzeri teknolojiler kullanılır.\n  Uygulama güvenliği: Uygulama güvenliği, ağ üzerinde çalışan uygulamaların güvenliğini sağlamayı amaçlar. Bu katmanda, uygulama güvenlik duvarları, uygulama katmanı şifreleme protokolleri ve benzeri teknolojiler kullanılır.\n  Yönetim güvenliği: Yönetim güvenliği, ağın yönetimini sağlayan cihazların güvenliğini sağlamayı amaçlar.\n  LAN, WAN ve MAN #  LAN, WAN ve MAN, bilgisayar ağlarındaki farklı ağ tiplerini ifade eden terimlerdir.\n  LAN (Local Area Network): LAN, kısa mesafelerde birbirine bağlı olan cihazlar arasında veri iletişimi sağlayan ağlardır. Örneğin, bir ofis binasında birkaç bilgisayarın birbirine bağlı olduğu ağlar LAN örnekleri olabilir.\n  WAN (Wide Area Network): WAN, geniş alanlarda uzak cihazlar arasında veri iletişimi sağlayan ağlardır. İnternet, bir WAN örneğidir. Bir şirketin merkez ofisi ve şube ofisleri arasında uzak mesafelerde bağlantı kurmak için kullanılan özel hatlar da WAN örnekleridir.\n  MAN (Metropolitan Area Network): MAN, bir şehir veya bir bölge gibi kısmen daha büyük bir alanı kapsayan ağlardır. MAN\u0026rsquo;lar, birkaç farklı LAN\u0026rsquo;ın birbirine bağlanması ile oluşabilir.\n  Bu üç ağ türü, özellikle boyutları ve kapsama alanları açısından birbirlerinden farklıdırlar. LAN\u0026rsquo;lar küçük bir alanda kullanılırken, WAN\u0026rsquo;lar geniş alanları kapsar ve MAN\u0026rsquo;lar ise LAN ve WAN arasında bir orta nokta sağlar.\ntcp/ip #  TCP/IP, İletişim Protokolü (TCP) ve İnternet Protokolü (IP) gibi bir dizi protokolden oluşan bir ağ iletişim protokolüdür. Bu protokol, İnternet\u0026rsquo;in temel altyapısıdır ve birçok farklı cihazın birbirleriyle iletişim kurmasını sağlar.\nTCP, verilerin kesintisiz bir şekilde aktarılmasını sağlar ve iletişim sırasında hata kontrolü ve yeniden aktarım gibi özellikler sunar. IP ise, ağdaki cihazların adreslerini belirleyerek verilerin doğru hedeflere yönlendirilmesini sağlar.\nTCP/IP, birçok farklı uygulama tarafından kullanılan bir protokoldür ve internet bağlantısı sağlayan cihazlar arasındaki iletişimde de kullanılır. Bu protokolün kullanılması, verilerin güvenli ve doğru bir şekilde iletilmesini sağlar.\n"},{"id":58,"href":"/linux-training/docs/101/linux/terminoloji/","title":"Terminoloji","section":"Linux","content":"process #  İşlem(process), o anda sistemde çalışan derlenmiş kaynak kodudur.\nPID #  Tüm işlemlerin bir işlem kimliği veya PID\u0026rsquo;si vardır.\nPPID #  PPID (Parent Process ID - Ebeveyn İşlem Kimliği), bir işlemin oluşturulduğu ana işlemi tanımlayan bir numaradır. Yani, herhangi bir işlem oluşturulduğunda, bu işlem bir ana işlem tarafından başlatılmışsa, bu işlemin PPID\u0026rsquo;si, ana işlemin kimliği olacaktır. PPID, işletim sistemi tarafından kullanılır ve işlemlerin yönetimi için önemlidir. Örneğin, bir işlem sona erdiğinde, işletim sistemi, bu işlemin PPID\u0026rsquo;sine sahip olan ana işlemi kontrol ederek, gerektiğinde onu sonlandırabilir. PPID, işlemler arasındaki hiyerarşik yapıyı tanımlamak için de kullanılır. Her işlem, bir ana işlemin altında veya birçok çocuk işlemi ile birlikte olabilir ve PPID, bu ilişkileri belirlemek için kullanılır.\ninit #  init, Unix benzeri işletim sistemlerinde sistem açılışının ve işlem yönetiminin başlangıcını yöneten ilk işlem (process) olarak adlandırılır. init, önyükleme (boot) sürecinde, işletim sistemi çekirdeği yüklendikten sonra çalıştırılır ve sistemin diğer işlemlerinin başlatılmasından sorumludur.\ninit, önceden belirlenmiş bir dizi işlemi (runlevel) belirli bir sırayla başlatır. Bu işlemler, sistem için gerekli olan servisleri, bağımlılıkları ve diğer ayarları yükler. Bu nedenle, init, sistemin stabil bir şekilde başlaması için önemli bir role sahiptir.\nGeleneksel olarak, init\u0026rsquo;in kullanıldığı sistemlerde 0\u0026rsquo;dan 6\u0026rsquo;ya kadar altı farklı runlevel vardır. Bu runlevel\u0026rsquo;lar, sistemde çalışan servislerin durumunu ve hangi hizmetlerin çalıştırılacağını belirler. Örneğin, runlevel 1, sistemi bir kurtarma modunda başlatırken, runlevel 5, bir grafiksel kullanıcı arabirimini (GUI) başlatmak için kullanılabilir.\nModern Linux dağıtımlarında, systemd gibi yeni init sistemleri kullanılır. Bu sistemler, geleneksel init sistemlerine göre daha hızlı başlangıç süreleri ve daha iyi ölçeklenebilirlik özellikleri sunarlar.\nkill #  Unix benzeri işletim sistemlerinde bir işlemi sonlandırmak veya durdurmak için kullanılan bir sistem çağrısıdır. Bu işlem, önceden belirlenmiş bir işlem kimliği (PID - Process ID) kullanılarak gerçekleştirilir.\nkill komutu, genellikle bir işlemin normal şekilde durdurulamadığı veya donduğu durumlarda kullanılır. Bu durumlar, bir programın yanıt vermediği veya sistem kaynaklarına erişememesi nedeniyle kilitlendiği zamanlarda ortaya çıkabilir.\ndaemon #  İşletim sistemlerinde arka planda sürekli olarak çalışan bir işlemdir. Bu işlemler, kullanıcının doğrudan etkileşimine ihtiyaç duymayan servisler, arka plan hizmetleri, görevler ve uygulamalar olabilir.\nzombie #  Bir işlem, normal olarak sonlandırıldığında, işletim sistemi tarafından sonlandırıldığına dair bir sinyal alır. Ancak, işlem sonlandırma sinyali alınamadığında veya işlem sonlandırılamadığında, işlem \u0026ldquo;zombie\u0026rdquo; durumuna geçer.\n"}]